#import "@preview/numbly:0.1.0": numbly
#import "@preview/theorion:0.3.3": *
#import cosmos.rainbow: *

#import "/typ/templates/blog.typ": *

#show: main.with(
  title: "计算机网络复习笔记",
  desc: [计算机网络复习笔记],
  date: "2025-06-25",
  tags: (
    blog-tags.network,
  ),
  license: licenses.cc-by-nc-sa,
)

/*
#show table: it => align(center, it)
#show table: block.with(width: 100%)
*/

#show math.equation.where(block: true): if is-pdf-target {
  block.with(width: 100%)
} else {
  x => x
}


#let (problem-counter, problem-box, problem, show-problem) = make-frame(
  "problem",
  "例",
  inherited-levels: 1,
  inherited-from: heading,
  render: render-fn.with(fill: rgb("#1F2421")),
)

#let (solution-counter, solution-box, solution, show-solution) = make-frame(
  "solution",
  "解",
  inherited-levels: 1,
  inherited-from: heading,
  numbering: _ => { (..x) => {} },
  render: render-fn.with(fill: rgb("216869")),
)

#show: show-theorion
#show: show-problem
#show: show-solution

#let Bytes = "Bytes"
#let Kbps = "Kbps"
#let Mbps = "Mbps"
#let Gbps = "Gbps"
#let kbps = "kbps"
#let ms = "ms"
#let MHz = "MHz"
#let bit = "bit"
#let bits = "bits"

= 绪论
- 单位:
  - 字节: 大 B, 存储介质中存储的数据量
  - 比特: 小 b, 吞吐量
- 参考模型: OSI 七层, TCP/IP 四层
  #table(
    columns: 3,
    align: center + horizon,
    [OSI 模型], [TCP/IP 模型], [功能],
    [应用层], table.cell(rowspan: 2)[应用层], [应用],
    [表示层], [数据表示, 格式转换, 加解密],
    [会话层], table.cell(rowspan: 2)[传输层], [管理两个端点的通信, 建立, 维护, 拆除会话],
    [传输层], [端点(不一定是主机)间的数据段传输],
    [网络层], [网络层], [路由],
    [链路层], table.cell(rowspan: 2)[网络接口层], [可靠帧传输],
    [物理层], [透明比特流传输],
  )


= 物理层
透明传输比特流.

#problem[
  在一根有传输延迟为 5ms 的 4Mbps 链路上发送 500 字节的消息, 此消息从发送到传播至目的地的延迟共有多少?
  #solution[
    链路的吞吐量(带宽)决定了发送数据的速度, 延迟决定了最后一个数据包从发出到到达的时延, 于是
    $
      L = M/R + D = (500 Bytes)/(4 Mbps) + 5 ms =6 ms
    $
  ]
]

#problem[
  在一个传播延迟为 4ms 的 5Mbps 互联网访问链路上, 传输数据最大数量是多少?
  #solution[
    这里的"传播延迟"其实是"可以容忍的从首个数据发出到最后一个数据接收之间的时间", 所以
    $
      "BD" = R D = 5 Mbps dot 4 ms = 2500 Bytes
    $
  ]
]

#problem[
  1bit在一个传输速度为 1 Gbps 的有线网络上可以传播多远? 假设通过线传播的信号的传播速度是真空中光速的 $2 slash 3$.
  #solution[
    其实是想问"最后一个数据发出时, 第一个发出的数据已经传播了多远", 于是
    $
      (1 bit)/(1 Gbps) dot 2/3 dot c = 20 "cm"
    $
  ]
]


== 信道的最大数字带宽
#theorem(title: [奈奎斯特定理])[
  显然超过 $S_max$ 的采样率没有意义, 所以没有噪声的理想信道的数字带宽上限是
  $
    R_max = S_max dot log_2 L
  $
  其中
  $
    S_max = 2 times B
  $
  是最大采样率, 是每秒采样的次数, $B$ 是频带范围, $L$ 是信号的离散级别, 比如采样两个二进制位, 则 $L = 2^2 = 4$.
]

#theorem(title: [香农定理])[
  在有噪声的信道里, 有
  $
    R_max = B times log_2 (1 + S slash N)
  $
  其中 $S slash N$ 是信噪比, 当其单位为分贝时, 有
  $
    S slash N ("db") = 10 times log_10 S slash N
  $
]

#problem[
  有一条4 kHz的无噪声信道, 每秒采样8000次, 如果每个采样是
  16比特, 则信道的最大传输速率是?
  #solution[
    其实我们不关心他实际上每秒采样多少次, 只关心信道本身的性质.
    $
      R_max = 2 dot 4000 dot 16 = 128 kbps
    $
  ]
]

#problem[
  如果一个二进制信号通过一条 4 kHz的噪声信道, 噪声是30分贝, 则最大传输速率是?
  #solution[
    $
      R_max = 4000 dot log_2 (1 + 1000) approx 40 kbps
    $
  ]
]

#problem[
  如果一条信道的带宽在 3MHz和4MHz之间, 且信噪比是24分贝, 问:
  + 信道的传输能力(最大传输速度)如何?
  + 为了达到这个传输能力, 信号级别需要多少级?
  #solution[
    注意两个公式里面的 $B$ 都是频带范围, 所以这里的 $B$ 应该是
    $
      B = 4 MHz - 3 MHz = 1 MHz
    $
    + $
        S slash N = 10^(24/10) \
        R_max = B log_2 (1 + S slash N) approx 8 Mbps
      $
    + $
        R_max < 2 B log_2 L => L >= 16
      $
  ]
]


== 编码和调制
- 编码: 对数字信号
  - 归零: 正负电平, 发送完回到 0
  - 非归零: 正电平和负电平
  - 非归零逆转: 传输 0 时逆转信号, 传输1时不变
  - 曼彻斯特: 使用向上, 向下跳变行为编码 0, 1
  - $x$b/$y$b 编码: 用 $y$ 位前缀码编码 $x$ 位数据.
- 调制: 对模拟信号
  - 调幅
  - 调频
  - 调相
  - 综合调制: QAM-$n$ 代表有 $n$ 个信号级别, 每个码元表示 $log_2 n$ 比特数据


== 复用
在单个信道中传输多个信号.
- 时分复用 TDM: 在小的时间片上轮流使用信道. 一种方法是均分, 还可以使用统计时分复用(STDM)的方法根据用户需求分配时间片.
- 频分复用 FDM: 把物理带宽分为若干频率范围, 形成子频带和子信道, 子信道之间可以有很窄的保护带. 计算子信道带宽时, 直接用总带宽除以子信道数量. 有一种技术是正交频分复用(OFDM), 相邻信号必须正交, 但是信道可以重叠, 从而能提升信道的总带宽.
- 波分复用 WDM: 光信号的FDM.
- 码分复用 CDM: 把每个连接的一个比特分为到 $m$ 个时间间隔中发送, 这些离散的时间是*码片*, 把 1 编码为 $m$ 维的双极向量(分量为 $plus.minus 1$), 称为*码片序列*. 所有用户的码片序列两两正交, 所以可以全都混在一起线性叠加地发送, 接收方只需要用自己的码片和接收的叠加信号点积, 观察结果 ($m$, $0$, $-m$) 就能得知发送内容.

#problem[
  五个用户使用 TDM 或 FDM 共享1 Mbps 链路. 使用 TDM的每个用户都要以一个固定的顺序轮流完全占据链接 1 ms. 使用FDM的每个用户在所有时间中获得 1/5 的链路. 当用户传输一个 1250 字节的消息时, 哪个方法具有最低的可能延迟, 且该延迟时间是多少?
  #solution[
    - TDM: 每个 1ms 内可以发送
      $
        1 ms dot 1 Mbps = 125 Bytes
      $
      故共需要等待 9 个 $4 ms$ 和发送 10 个 $10 ms$, 共 $46 ms$.
    - FDM:
      $
        (1250 Bytes)/((1 Mbps)/5) = 50 ms
      $
    故为 TDM, 46 ms.
  ]
]

== 介质
- 同轴电缆
- 双绞线
  #table(
    columns: 3,
    [], [屏蔽双绞线 STP], [非屏蔽双绞线 UTP],
    [外屏蔽层], [有], [有],
    [线对屏蔽层], [有], [无],
    [尺寸], [大], [小],
    [重量], [重], [轻],
    [安装], [难], [易],
    [特点], [], [局域网中广泛使用],
  )
- 光纤: 光纤中不同入射角的光线可以互不干扰地传播, 每个入射角是一个"模式", 因此有多模光纤和单模光纤.
  #table(
    columns: 3,
    [], [单模光纤], [多模光纤],
    [发光器件], [半导体激光器], [发光二极管],
    [发光器件价格], [贵], [便宜],
    [发光器件寿命], [短], [长],
    [传输距离], [长], [短],
    [带宽], [大], [小],
    [芯线], [细], [粗],
  )
- 非导引性介质, 如微波

== PSTN
#table(
  columns: (auto, auto, auto, auto),
  align: horizon,
  [等级], [速率 (Mbps)], [路数], [说明],

  table.cell(colspan: 4)[Ex系列(欧洲/中国标准)],
  [E1], [2.048], [30], [],
  [E2], [8.448], [120], [4 倍 E1],
  [E3], [34.368], [480], [4 倍 E2],
  [E4], [139.264], [1920], [4 倍 E3],
  [E5], [565.148], [7680], [4 倍 E4],

  table.cell(colspan: 4)[Tx系列(北美/日本标准)],
  [T1], [1.544], [24], [],
  [T2], [6.312], [96], [4 倍 T1],
  [T3], [44.736], [672], [7 倍 T2],
  [T4], [274.176], [4032], [6 倍 T3],
)


== 设备
- 放大器: 去噪和放大信号, 多用于总线拓扑
- 集线器: 收到信号广播给其他所有节点, 多用于星形拓扑

= 链路层
负责把数据打包成帧, 并做纠错和流量控制.


== 成帧
- 字节计数法: 帧头标记这一帧多大, 但是第一帧错了就全完了.
- 带字节填充的字节标记法: 用一个特定的定界符 FLAG(一个特殊字节) 来标记首尾. 包长度只能是字节为单位, 如果包中间也出现了 FLAG 就要用特定的转义符ESC (也是一个特殊字节)转义, ESC自身也转义.
- 带位填充的位标志法: 允许一帧为任意长度. 起始和终止标志是 01111110(中间有6个1), 但是中间如果发送了五个连续的1, 就会强制发送一个 0, 所以永远都不会重复. 接收方收信的时候碰到五个1接一个0就会把0删掉.
- 物理层编码违例: 如果物理层用跳变编码 0 和 1, 那可以留出来连续高(低)电平定界.


== 检错和纠错
=== 奇偶校验
通过在数据后 append 一位, 保证整个帧的所有 1 的个数是奇数或者偶数.


=== CRC
- 发方
  + , 定 $r$ 阶多项式 $G=sum_(i = 0)^r g_i x^i$, 其中 $g_i in {0, 1}$, 于是可以仅取系数表示为 $r+1$ 位二进制数 $G$, 高阶对应高位.
  + 对数据 $M$, 左移 $r$ 位, 也即 $x^r M$.
  + 作模二除法 $x^r M slash G$ 余数为 $c$
    - 二进制除法中直接使用异或作为加减法, 不需要试商, "够除"只看位数
  + 把 $r$ append 上 $c$, 作为真实发送的数据
- 收方
  + 对收到的信息作模二除法查看是否能被 $G$ 整除, 若不能则出错, 若能则无错.

#problem[
  用标准 CRC 方法来传输位流 10011101. 生成多项式为 $x^3+1$.
  + 试问实际被传输的位串是什么?
  + 假设在传输过程中从左边数第三位变反了. 请说明这个错误可以在接收端能否被检测出来.
  + 给出一个该比特流传输错误的实例, 使得接受方无法检测出该错误.
  #solution[
    $
      G = 1001
    $
    + 有
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          [], [ ], [1], [0], [0], [0], [1], [1], [0], [0], [1], [0], [0],
          table.hline(start: 1),
          [1001], $)$, [1], [0], [0], [1], [1], [1], [0], [1], [0], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 10),
          [], [ ], [0], [0], [0], [0], [1], [1], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [],
          table.hline(start: 6, end: 11),
          [], [ ], [ ], [ ], [ ], [ ], [0], [1], [0], [0], [0], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [],
          table.hline(start: 7, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [1], [0], [0],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0],
        )
      })
    故为 10011101100.
    + 若第三位取反, 也即接收到 10111101100, 则
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          [], [ ], [1], [0], [1], [0], [1], [0], [0], [0], [0], [0], [0],
          table.hline(start: 1),
          [1001], $)$, [1], [0], [1], [1], [1], [1], [0], [1], [1], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 8),
          [], [ ], [0], [0], [1], [0], [1], [1], [], [], [], [], [],
          [], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [], [ ], [ ],
          table.hline(start: 4, end: 10),
          [], [ ], [ ], [ ], [0], [0], [1], [0], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [ ],
          table.hline(start: 6, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [0], [1], [0], [0],
        )
      })
      余数不为 0, 故检测到出错.
    + 只需要令正确数据再异或(加)上除数即可
      $
        10011101100 xor 1001 = 10011100101
      $
  ]
]

=== 互联网校验和
+ 发送方: 把数据按一定比特长度分为多个位串, 然后执行反码求和, 得到的即为校验和
+ 接收方: 把收到的数据按同样方式分为多个位串, 把这些位串和校验和做反码求和, 得到 0 即为无错误, 得到 1 则为有错误.

=== 纠1位错的海明码
两个位串中不同的位的个数为这两个位串的海明距离(也即 xor 后统计 1 的个数).

一个编码中任取两个码字, 最小的海明距离就是这个编码的海明距离.

海明距离为 $d + 1$ 的编码方案能实现 $d$ 位的错误检测, 因为只有 $d + 1$ 位同时发生错误才有可能不被察觉地从一个编码变为另一个.

令码字长度
$
  n = m + r
$
求出最小 $r$ 满足
$
  m + r + 1 <= 2^r
$

这 $n$ 位中 $r$ 位是校验码, 分布在从第一位开始的 2 的幂次位上.

编码时, 把原数据每一位的序号分解为 2 的幂的和. 然后对于每一个2的幂位置的校验码, 取出所有分解包含该位置序号的位, 把这些位异或(或者做奇偶校验)就能得到这个校验码的值.

解码时, 按编码的方式重新计算校验位, 并且统计所有不一致的校验位. 如果全都一致, 那么认为没有错误, 如果有不一致, 把所有出错校验位的序号加起来就是出错的实际位的序号, 把那一位取反即可.

#problem[
  偶校验纠1位错海明码编码 10101111.

  #solution[
    $
      m = 8 \
      m + r + 1 <= 2^r => r >= 4
    $
    使用 4 位纠错码, 则
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], [], [], [1], [], [0], [1], [0], [], [1], [1], [1], [1],
      [纠错码1], [1], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [0], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], .."101001001111".clusters(),
    )
  ]
]

#problem[
  偶校验纠 1 位错海明码纠错 100110001100, 其中 $m = 8$, $r = 4$.
  #solution[
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], .."100110001100".clusters(),
      [纠错码1], [0], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [1], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [1], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], sym.crossmark, sym.crossmark, [], sym.checkmark, [], [], [], sym.checkmark,
    )
    故第 $1 + 2 = 3$ 位出错, 取反, 正确值为 101110001100.
  ]
]

== 可靠传输
=== 停等
接收方收到正确数据返回一个确认帧 ACK, 否则什么都不发. 发送方收到确认帧就发下一帧, 若长时间没有收到就重传这一帧(ARQ, 自动重复请求协议).

由于是一帧一帧地发, 所以只需要一位二进制标识帧号, 在发送和确认时传送.

信道利用率
$
  "util" = T_"data" / (T_"data" + T_"ACK" + 2 l)
$
常常认为 $T_"ACK"$ 为 0, 因为比较小. $l$ 为延迟.

#problem[
  使用 ARQ 协议在一个 1 Mbps 链路上发送一系列的 1250 字节消息. 此链路的传播延迟为 5 ms. 问可以使用的链路带宽的最大百分比是多少?
  #solution[
    $
      T_"data" = (1250 Bytes)/(1 Mbps) = 10 ms \
      "util" = (10 ms)/(10 ms + 2 dot 5 ms) = 50%
    $
  ]
]

=== 滑动窗口
同时进行 $w$ 个停等.

信道利用率
$
  "util" =(w T_"data") / (T_"data" + T_"ACK" + 2 l)
$

可以看出只要窗口够大, 热身后利用率就能达到 $100%$.

出错时有两种方案
+ 回退 n 帧 GBN: 从出错那帧(没收到 ACK 开始)全部重发, 需要发送方有较大缓冲区, 因为发送方需要重传. 窗口最大为 $"MAX_SEQ"$, MAX_SEQ 为最大序列号(从 0 开始). 可以结合无滑动窗口的情况记忆, 也即序号从 0 开始, 最大为 1 , 窗口也为 1 .
+ 选择性重传: 只重传出错的帧, 需要接收方有较大缓冲区, 因为要等待和排序收到的帧. 窗口最大为 $("MAX_SEQ" + 1) slash 2$

这种最大窗口区别的本质是回退 n 帧的渐进的, 即使只确认了一个也能向下滑动, 而选择性重传是累计的, 本窗口必须全部完成才能向下滑动. 因此回退n帧只需要提供 1 的冗余, 而选择性重传需要提供一个完整窗口的冗余.

#problem[
  两台主机之间的数据链路层采用了回退 n 帧协议(GBN)传输数据, 数据传输速率为 16 kbps, 单向传播延迟是 270 ms, 数据帧长度为 128 - 512B, 接收方总是以数据帧等长的帧进行确认, 为使得信道利用率达到最高, 帧序号的比特数至少为多少位?
  #solution[
    要求至少, 所以我们求上界, 取数据帧长度 128 Bytes.
    $
      T_"data" = T_"ACK" = (128 Bytes)/(16 Kbps) = 64 ms \
      "util" = w (64 ms)/(2 dot 64 ms + 2 dot 270 ms) => w > 10
    $
    取 $w = 11$, 则帧序号至少有 $0 ~ 11$, 也即至少 4 位.
  ]
]

= 介质访问控制和局域网
一条信道需要被许多工作站共享, 因此需要考虑信道的分配和使用, 这就是 MAC 介质访问控制, 这部分功能由 MAC 层完成.

== 多路访问协议
目的是为了让每台工作站都有信道的部分使用权. 分为
- 随机访问协议
- 受控访问协议
- 有限竞争协议

=== 随机访问协议
工作站不是提前获得预分配的资源, 而是有了要传输的数据帧之后, 用一种机制竞争共享信道的使用权.

==== 纯 ALOHA 协议
"任性", 所有计算机想发就发.
- 如果发送成功, 接收站回一个确认帧, 网络中有一个特殊计算机会把收到的确认帧广播出去, 发送站收到了确认帧就认为发送成功.
- 如果同时有两台计算机在发送信息, 就会发生碰撞, 发送失败, 无法通过 CRC 校验, 于是会遵循二进制指数回退算法进行重传.

#definition(title: "二进制指数回退算法(BEB)")[
  第 $k$ 次传输失败, 从 $[0, 2^k- 1]$ 中随机抽一个时间等待后再重发.
]

#theorem[
  ALOHA 协议的吞吐量为
  $
    S = G e^(-2G)
  $
  其中 $G$ 是每个标准帧时(传输一个数据帧需要的时间)内产生和重传的平均数据帧数.
]

==== 分槽 ALOHA 协议
把时间离散化, 存在某些同步的时隙的开始, 只有在开始处才能发信.

#theorem[
  分槽 ALOHA 协议的吞吐量为
  $
    S = G e^(-G)
  $
]

==== CSMA载波侦听多路访问系列
===== 非持续 CSMA
要发信的时候先侦听信道是否在使用, 如果在用, 就先等待一个随机时间再来, 如果没在用, 就发.

===== $p$-持续 CSMA
要发信的时候先侦听信道是否在使用, 如果在用, 那就一直监听, 直到空闲. 如果发现空闲, 有概率 $p$ 发信, $1-p$ 空出一个时隙再监听.

===== 1-持续 CSMA
$p$-持续 CSMA 的一种特例.

===== 带冲突检测的 CSMA (CSMA/CD)
即使使用上述策略, 还是有冲突的可能.

CSMA/CD 的网卡有发送器Tx和接收器Rx, Tx发信的时候也给Rx一份, Rx同时也会监听网络上的信号, 如果Rx监听到两个信号一样, 就说明没冲突, 如果检测到冲突, 就停止发送, 并且广播一个拥塞信号 jam.

冲突只能在开始发送后 $2D$ ($D$ 是最远的一台机器的时延)时间内发生, 这是显然的: 极端情况本机消息的头部与另一条消息的头部发生碰撞并被最远的一台机器检测到, 其广播 jam 并被本机接收. 这个时间是冲突窗口, 只要在这个时间内没有检测到冲突, 就说明发送成功.

同时, $2D$ 也是最小帧长, 因为如果比此长度还短, 即使检测到冲突, 消息也已经发完了.

经典以太网使用 CSMA/CD, 除此了上面描述的之外, 还有以下设计
- 检测到冲突后重发的等待时间使用 BEB
- 如果失败次数超过了 15 次, 放弃重发

#problem[
  在经典以太网中, 有A, B和C共3个站点, 采用CSMA/CD 和 BEB(二进制指数回退算法). 假设所有站点都未开始发送消息. 当下面这些事件按顺序发生之后, 哪些说法是正确的? 你观察这些事件的顺序:
  + A 成功发送了一帧
  + A 和 B 都发送了帧, 出现冲突
  + A 成功地重新发送了一帧

  A. A将重新等待两个时隙\
  B. A和B处于不同的工作状态\
  C. B准备好发送下一帧, 不执行BEB\
  D. B已经等待了至少两个时隙

  #solution[
    AB冲突后, 他们按照BEB将从 ${0 ,1}$ 个时隙中随机选择进行等待, 之后 A 成功发送而 B 暂时没有发送表明 A 选择等待 0 时隙, B 选择等待 1 时隙, 故显然选择 BD.
  ]
]

#problem[
  假定1km长的CSMA/CD网络的数据率为1Gb/s. 设信号在网络上的传播速率为200000km/s. 求能够使用此协议的最短帧长.
  #solution[
    $
      2D = 2 dot 1000/(200000 dot 10^3) = 10^-5 \
      1 Gbps dot 10^-5 = 10^4 bits = 1250 Bytes
    $
  ]
]

===== 带冲突避免的 CSMA (CSMA/CD)
有确认机制.

=== 受控访问协议
==== 位图协议
$N$ 台机器发消息之前要先经过一个 $B$ 个比特时间的竞争期, 期间每台机器在各自的一个比特时间内发送 $1$ 举手表示自己有数据要发, 竞争期结束之后是传输期, $N$ 台机器根据比特位从低到高各自排队发送.

==== 二进制倒计数协议
上一个协议中, 如果参与的计算机太多, 竞争期就会很大, 效率不高.

每个计算机分配一个 $log_2 N$ 的编号. 竞争期内相应地也有 $log_2 N$ 个比特时间, 每个比特时间内各自发送自己的对应位, 所有计算机在同一时间内发送的位求或, 如果一台机器发现结果和自己的对应位不一样, 那就退出竞争, 一直这样决出得到发送权的机器.

有优先级, 编号越大优先级越高.

==== 令牌传递协议
令牌在环状的网络中轮流.
- 发信: 取得令牌时, 查看令牌中有无数据
  - 无数据: 把数据插入令牌, 令牌成为数据帧. 当令牌下一次到达时, 本机负责把令牌中的数据删除
  - 有数据: 等待令牌下一次到达
  然后把令牌递给下一台机器
- 收信: 取得令牌时, 查看令牌中有无数据, 数据是否发给自己, 如果是, 那么受到了数据, 然后把令牌递给下一台机器


== 以太网
从参考模型看, 这部分设计覆盖了物理层和数据链路层, 但是 IEEE 802.3 只覆盖了物理层和 MAC.

=== 分类
==== 经典以太网
使用 CSMA/CD, 曼彻斯特编码, 有以下几种传输介质
#table(
  columns: 4,
  align: center,
  [特点], [10Base-5], [10Base-2], [10Base-T],
  [线缆类型], [粗缆], [细缆], [双绞线],
  [最大长度], [500m], [185m], [100m],
  [安装难度], [不易安装], [比粗缆易安装], [],
  [拓扑结构], [物理总线拓扑], [], [物理星状拓扑, 逻辑总线拓扑],
)

线缆名字中, 10 是指速度为 10mbps, 前二者的 5 和 2 指的是传输距离, 后者的 T 指的是传输介质.

==== 交换式以太网
集线器, 中继器慢慢被交换机替代, 形成了交换式以太网.

交换机可以对所连接的任意两个接口进行无冲突的通信(通过交换机内部 $n^2$ 的阵列交换点形成虚拟电路), 端口和工作站形成无冲突域, 每个端口所在的 LAN 段形成独立冲突域, 效率高.

如果交换机端口不是全双工, 而是半双工, 那还是要用 CSMA/CD 防止冲突.

=== 帧格式
精品背书课.

==== 地址
最高字节的最低位是单播(0)/组播(1)切换位, 次位是全局(0)/本地(1)切换位.

=== L2 交换
交换机需要按照地址把数据发送到对应端口, 但是交换机是即插即用的透明设备, 需要学习才能知道什么端口是谁.

当数据来到交换机的时候, 以下情况:
+ 交换机的地址表中不存在目标地址, 或者目标地址就是广播地址, 于是广播(向除了源端口的其他端口发送), 并且把源端口和其地址记录(或更新)在路由表中
+ 交换机的地址表中存在目标地址
  + 目标地址对应的端口就是源端口, 丢弃这一帧, 并更新路由表中的源端口地址
  + 目标地址对应的端口不是源端口, 把一帧传送到目标端口, 并更新路由表中的源端口地址

表中存储的地址-端口对都是有时限的, 如果长时间没有更新就会删除.

交换方式有三种:
- 存储转发: 缓存完整帧, 然后转发. 转发前要进行CRC校验. 出错少, 但是慢
- 直通交换: 读取到帧的目标地址后, 立即在源端口和目标端口之间建立通道, 转发这一帧, 出错多, 但是快
- 无分片交换: 介于两者之间. 接收到帧的前64帧再开始转发, 因为冲突往往在刚开始传输的 64 字节内, 这样做可以过滤冲突碎片.

网桥就是旧版本的交换机, 行为和交换机一样.

== VLAN
人工限制交换机的广播域, 使用的标准是 IEEE802.1Q.

= 网络层
寻路.

提供的服务有两种.
#table(
  columns: 3,
  [服务], [数据报网络], [虚电路网络],
  [有无连接], [无], [有],
  [数据寻径], [每个分组独立寻径], [每个分组只带有连接号, 不需要自己寻径],
  [抗毁性], [故障不会瘫痪网络, 分组可以自由寻路], [连接发生故障需要重新搭建],
  [到达顺序], [乱序到达], [按序到达],
  [状态], [无状态], [有状态],
  [服务质量], [难以保证], [可以保证],
)

== IPv4 协议


=== 分组格式
精品背书课.


=== 分片
链路层的 MTU 的限制会导致分片.

IPv4 分组中存在标记位:
- DF(Don't Fragment): 若为 0 表示可以分片, 为 1 表示不要分片
- MF(More Fragment): 若为 0 表示这是最后一个分片, 为 1 表示还有更多分片

如果分组长度 $L$ 大于转出网络 MTU $M$(对于以太网来说, MTU 是 1500 Bytes), 且分组中 DF 为0, 那么一片的载荷长度为
$
  d = floor((M - H)/8) * 8
$
这里是为了保证分片长度为8字节整数倍, 因为分片偏移的单位是8字节.

总分片数为
$
  n = ceil((L - H)/d)
$
其中 $H$ 为头部长度, 往往为 20.

#problem[
  节点 A 到 B 通过路由器 R1 和 R2 路由. 通过网络发送的 IP 数据报有 20 字节长的报头. A-R1 链路的 MTU 是1800 字节, R1-R2 链路的 MTU 是 1200 字节, R2-B 链路的 MTU 是 600 字节. 如果 A 想要发送长度为 2800 的消息, 问: B 接收的数据报的总个数是多少? (假定源数据报中的DF=0).

  #solution[
    首先计算出各个链路允许的最大有效载荷.
    $
      floor((1800-20)/8) dot 8 = 1776 Bytes \
      floor((1200-20)/8) dot 8 = 1176 Bytes \
      floor((600-20)/8) dot 8 = 576 Bytes \
    $

    于是
    $
      (2800) cases(
        1796(1776) cases(
          1196(1176) cases(
            596(576),
            596(576),
            44(24)
          ),
          620(600) cases(
            596(576),
            44(24)
          )
        ),
        1044(1024) cases(
          1044(1024) cases(
            596(576),
            468(448)
          )
        )
      )
    $
    共 7 个.
  ]
]

=== IPv4 地址
一些特殊地址
#table(
  columns: 3,
  [名称], [地址], [备注],
  [受限广播地址], [全1], [只做目的地址, 向全网主机广播, 实际上只是本地广播],
  [未指定地址], [全0], [只用作特殊情况下的源地址],
  [网络广播地址], [网络号.全1], [只做目的地址, 向对应网络],
  [网络地址], [网络号.全0], [不做源或目的地址, 代表网络本身],
)

私人地址空间:
- 10.\*
- 172.16.\* - 172.31.\*
- 192.168.\*

ABCD类地址: 看第一个八位组开头有几个连续1, 0个是A, 1个是B, 依此类推.

=== 子网划分
先分配地址多的, 再分配地址少的, 分配的时候可以基本按照树状的分配方式.

需要注意, 如果子网内有 $n$ 台客户机需要上网, 则实际上至少需要 $n+3$ 个IP, 因为需要
- 子网本身的地址
- 子网广播地址
- 网关自身的地址


=== 其他IP协议或技术
==== ARP地址解析协议
主机发信需要对方的MAC, 但是有时候只知道IP不知道MAC, ARP就是用来通过IP获得MAC的协议.

===== 数据帧格式
精品背书课.

===== 基本工作原理
基本工作方式为:
+ 一方发送ARP请求, 其中目标硬件地址保留全零
+ 由于目标地址是广播地址, 所有主机都会接受
+ 除了目的主机, 其他主机不理睬
+ 目的主机收到后发送ARP应答, 其中所有地址都填好
+ 源主机收到应答并获得地址

每个主机都会维护一个ARP表, 按如下方式更新
- 发出请求, 接到应答后按应答更新
- 收到请求的主机, 无论是不是目标, 都提取请求中的发送方地址更新

实际上记录都有生存时间, 时间太长自动删除. 如果主机启动或者重新配置网卡, 主机会广播一个免费ARP请求, 目标和发送方都是他自己, 之前存储过这台机器的接收到这个请求就会用里面的信息更新.

如果是对远程网络中的主机ARP, 则最开始要把路由器MAC设置为目标MAC, 路由器拿到ARP请求后再根据IP地址在网络层进一步处理, 直到路由器拿到MAC地址, 再重新封装一个ARP应答发给源主机.

==== ICMP
- 不可达: 超时
- 拥塞: 源抑制

==== NAT网络地址转换
让多个私有IP的主机通过同一个公有IP连接外部网络, 具体做法就是
- 内网分组到达NAT转换器, NAT转换器修改源IP为公有IP, 并且分配一个端口号, 对转换前后的端口号和源IP做好记录
- 转发
- 收到回信, 按照记录好的端口号, 源IP修改回信
- 转发

这个服务是完全透明的.

== IPv6 协议

=== IPv6地址
128位, 记作 $8 times 4 times 4$ 的冒分十六进制. 也有和 IPv4 一样的前缀表示法.

省略规则:
- 前导零必须省略, 如 $0001 -> 1$
- 最长零省略, 如果有连续多组四位十六进制全为0, 那就全都省略为一个 `::`, 最长的优先, 等长最前面的优先, 不省略一组0.


=== IPv6 过渡技术
- 双协议栈技术
  - 一般: 一个机器同时支持两种协议, 要和什么协议的机器交互就用什么协议
  - 双协议栈过渡机制: 在最后的过渡期服务少数的 IPv4 主机, 在一个纯 IPv6 网络内提供一个类似 NAT 服务的 DSTM 服务器和一个双栈的 TEP 端点, 网络内主机通过 DSTM 获取 NAT 后的 IPv4 地址, 把整个包封在 IPv6 帧里面通过 TEP 和纯 IPv4 主机交互.
- 隧道技术
  - IPv6 over IPv4: 多为协议41封装, 也即 IPv4 分组中的协议字段为41, 数据段即为纯 IPv6 分组
  - IPv4 over IPv6
- 网络地址转换-协议转换 NAT-PT: 通过一个双栈网关作为代理沟通两种纯 vX 的主机(通过做NAT和PT), 但是对于部分双栈机器可以直通.


== 路由协议
寻路用.



=== 距离矢量路由协议(DV)
基本上分为三步
- 维护距离矢量
- 交换距离矢量
- 更新距离矢量

每个路由器维护一个他到其他所有节点的距离的矢量, 与邻居交换信息的时候通过自己到邻居这条路径优化自己的矢量.

RIP 协议就是一个 DV 协议的例子.

RIP 协议默认用跳数量度, 每个 RIP 路由器周期性和邻居交换, 默认30s一次, 最大量度为15跳, 再高认为不可达.


=== 链路状态路由协议(LS)
基本运作:
- 发现邻居: 通过 Hello 报文
- 设置链路: 了解自己和链路的状况, 并为此链路设置量度, 代价, 开销
- 构造 LSA(链路状态公告): 一个小地图, 包括邻居信息, 到邻居的链路, 链路上的量度
- 分发 LSA: 把LSA发给其他所有路由器
- 计算: 构建以自己为根, 到其他所有路由器的最短路径, 以及最短路径生成树

==== OSPF协议
开放, 使用带宽量度, 无类, 收敛快, 无路由环, 有层次性.

运行过程
- 建立全毗邻关系: 相互交换数据, 同步数据库
- 选举 DR指定路由器 和 BDR备用路由器: 为了减少同步次数
- 发现路由: 从邻居交换的信息里面获取新的路由
- 计算最佳路由
- 维护路由: 默认30min更新一次

用到五种报文.

全毗邻关系的建立过程和状态迁移.

== QoS
区分服务质量.

=== 漏桶算法
数据先传送到一个缓冲区, 从缓冲区中匀速抽取数据发送, 缓冲区满后超出的数据将会被丢弃.

不支持突发.

=== 令牌桶算法
漏桶算法的反演. 匀速向令牌桶中填充令牌, 令牌桶有一定容量, 多出的令牌将被丢弃, 数据只有从令牌桶中取得令牌才能发送.

支持一定程度的突发.

#problem[
  一个网络节点在网卡前接了一个令牌桶和漏桶, 令牌桶的容量C为10000KB, 令牌产生的速率是25MBps; 漏桶的容量是8000KB, 输出速率是125MB/s.
  + 如果网络节点产生了大量分组, 令牌桶的输出速度达到了50MB/s, 以这样的速度输出, 最多可以持续多长时间?
  + 如果网络节点某个时刻产生的分组突然增加, 产生了50MB的分组, 假如令牌桶已经在空闲时间积攒了满桶的令牌, 发送完50MB的全部分组, 需要多长时间? 不计算漏桶处理分组的时间.
  #solution[
    + 设能持续时间 $t$, 则有
      $
        25 t + 10 = 50 t => t = 0.4 "s"
      $
    + 设以 125 MBps 的速度输出了 $d$ 大小的数据, 则有
      $
        d/125 dot 25 + 10 = d => d = 12.5
      $
      持续 0.1s.

      之后又以 25MBps 的速度输出了 37.5 MB 数据, 持续
      $
        37.5/25 = 1.5 "s"
      $
      共 1.6s.
  ]
]

= 传输层
实现进程到进程的通信.

有无连接, 区别在于有无虚电路.
== UDP
可以用于 RPC 等.

=== 段格式
精品背书课.

== TCP

=== 可靠数据传输机制
+ 序号机制: 每个字节都有编号, 数据段的编号是第一个字节的编号.
+ 确认机制: 确认号是期望收到的下一个数据段的序号, 也即已经成功接收的数据号的后继. TCP 使用累计确认, 如果确认了后来的数据, 表示前面的数据也已经成功接收.
+ 重传机制
  + 计时器超时: 太长时间没收到确认就重传, 超时时间设置为预估的往返时间
  + 三次重复确认: 如果中间一个丢失了, 后面的正常发送, 于是对于后面正常接收的每一个, 都会回复一个丢失包的序号的确认, 三次重复确认就会使发送方重传.

=== 滑动窗口流量控制
TCP是全双工传输, 所以两方都各自维护自己的发送窗口和接收端口.

所谓窗口也即发出去了但是对方还没回复(自己还没处理完)的包的最大长度, 双方可以用数据段里面的接收窗口值告知对方调整发送窗口.

糊涂窗口综合征: TCP流控不良, 窗口非常小, 头部显得非常大, 额外开销过高. 解决方案有
+ Nagle算法: *发送方*先收集要发送的小数据, 到达一定量或者收到对方确认之后再发送.
+ Clark算法: *接收方*收到数据段就确认, 但是直到缓冲区足够大之前一直宣布窗口为0, 也即暂停接收.

拥塞窗口: 发送方维护, 用于限制自己, 不需要通告接收方. 实际的发送窗口是接收窗口和拥塞窗口的最小值.



#problem[
  如果一个TCP数据段的接收方, 向发送方发出了一个确认消息, 其中的ACK确认号和窗口尺寸两个字段的值分别是: ACK=12000, WIN=8000. 下列哪一项不是发送方的可以传输的有效的数据段?
  + 发送方可以传输 2000 字节数据段, SEQ = 18100
  + 发送方可以传输 1500 字节数据段, SEQ = 18100
  + 发送方可以传输 1000 字节数据段, SEQ = 18000
  + 发送方可以传输 2000 字节数据段, SEQ = 17000
  #solution[
    接收方确认到 11999, 期望 12000 的时候还有 8000 的窗口, 所以说新发给他的数据不能超过 8000, 也即末尾序号不能超过 $12000 + 8000 - 1 = 19999$, 显然第一个选项超过了.
  ]
]


=== 连接的建立
也即所谓三次握手:
+ 客户端向服务端, SYN设置为1, seq值设置为随机值 $x$, 数据段无数据, 但是占一字节
+ 服务端向客户端, SYN和ACK设置为1, seq为随机值 $y$, ack为 $x + 1$, 数据段无数据, 但是占一字节
+ 客户端向服务端, ACK设置为1, seq 为 $x+1$, ack为 $y + 1$, 这次可以包含数据, 也可以不包含, 也即数据长度为0

=== 连接的释放
分为
- 对称释放: 两方独立完成连接释放并收到对方确认
- 非对称释放: 只要一方完成连接释放的,请求并收到确认即可

==== 非对称释放
断开一方直接发送 DR 并关闭连接.

==== 对称释放
所谓四次挥手.

+ 客户端向服务端, FIN设置为1, seq 为 $x$(并非随机, 而是真实值), 数据占用1字节
+ 服务端向客户端, ACK为1, seq 为 $y$, ack为 $x+1$, 此时客户端向服务端的连接已经关闭.
+ 服务端向客户端, FIN为1, ACK为1, seq为 $z$(不一定是 $y+1$, 可能在单向连接关闭之后又发了一些), ack为 $x+1$, 数据占用1字节
+ 客户端向服务端, ACK为1, seq为 $x+1$, ack为 $z+1$, 然后等待两倍的最长段寿命(MSL, 一般为2min)后服务端向客户端的连接正式关闭



=== 计时器
TCP的状态需要多种计时器维护, 包括

==== 重传计时器
太长时间没收到确认就重传, 超时时间设置为预估的往返时间(RTT).

RTT的估计使用指数加权移动平均, 也即逐渐修正
$
  "SRTT" <- (1-alpha) "SRTT" + alpha R
$
其中 $alpha$ 是平滑因子, 越大则更新越平滑, 一般取 $alpha = 1 / 8$.

也有其他的估计方法.

==== 持续计时器
接收方有时候会把窗口设置为0主动停止接收信息, 直到他再次把窗口设置为其他值, 但是有时候还原窗口的消息丢失了, 这就会造成暂停状态无法解除.

所以我们设置了持续计时器, 如果*发送方*收到的消息中rwnd设置为0, 则开启计时器, 超时时则主动发送一个探测数据段(只有1字节新数据)触发对方重发一个确认数据段(which 重新设置了rwnd), 并且同时再启动一个新的持续计时器.

虽然探测数据段中有 1 字节新数据, 但是我们必须考虑接收方不会接收它(毕竟窗口officially还是0), 所以我们后续的数据段的seq忽略这1字节.

==== 保活计时器
防止长期空连接.

每收到一次客户端数据段就重置计时器, 超时的时候*服务端*就主动发送一个探测数据段, 连续10个探测数据段都没收到回应则认为客户端失联, 主动关闭连接.

==== 时间等待计时器
主要用于连接释放阶段, 也即前面提到的等待两倍的最长段寿命(MSL, 一般为2min)后服务端向客户端的连接正式关闭.

=== 拥塞避免
- 慢启动阶段: 有一个初始拥塞窗口大小, 比如 1 倍MSS(最大段数据), 每次发完收到对方确认后, 就把拥塞窗口加倍
- 拥塞避免阶段: 慢启动达到阈值(窗口达到阈值或者出现拥塞(超时))后, 进入线性增加阶段, 每次增加1MSS
- 网络拥塞时间发生阶段: 发生拥塞, 把阈值设置为当前拥塞窗口的一半, 然后拥塞窗口设置为1, 然后重新进入慢启动阶段
- 快速重传和恢复阶段: 如果只有个别数据丢失(比如三次重复确认), 就立即重传, 把阈值设置为窗口的一半, 窗口设置为新的阈值, 然后进入拥塞避免阶段

= 其它
== 各协议 PDU 相关数值
- 头部开销
  - IP: 20 Bytes
  - TCP: 20 Bytes
- MTU(包含头部)
  - IP: 576 Bytes
- 最大有效载荷
  - IP: 65515 Bytes
  - TCP: 65495 Bytes
