#import "@preview/numbly:0.1.0": numbly
#import "@preview/theorion:0.3.3": *
#import cosmos.rainbow: *

#import "/typ/templates/blog.typ": *

#show: main.with(
  title: "计算机网络复习笔记",
  desc: [计算机网络复习笔记],
  date: "2025-06-25",
  tags: (
    blog-tags.network,
  ),
  license: licenses.cc-by-nc-sa,
)

/*
#show table: it => align(center, it)
#show math.equation.where(block: true): block.with(width: 100%)
#show table: block.with(width: 100%)
*/


#let (problem-counter, problem-box, problem, show-problem) = make-frame(
  "problem",
  "例",
  inherited-levels: 1,
  inherited-from: heading,
  render: render-fn.with(fill: rgb("#1F2421")),
)

#let (solution-counter, solution-box, solution, show-solution) = make-frame(
  "solution",
  "解",
  inherited-levels: 1,
  inherited-from: heading,
  numbering: _ => { (..x) => {} },
  render: render-fn.with(fill: rgb("216869")),
)

#show: show-theorion
#show: show-problem
#show: show-solution

#let Bytes = "Bytes"
#let Kbps = "Kbps"
#let Mbps = "Mbps"
#let Gbps = "Gbps"
#let kbps = "kbps"
#let ms = "ms"
#let MHz = "MHz"
#let bit = "bit"

= 绪论
- 单位:
  - 字节: 大 B, 存储介质中存储的数据量
  - 比特: 小 b, 吞吐量
- 参考模型: OSI 七层, TCP/IP 四层
  #table(
    columns: 3,
    align: center + horizon,
    [OSI 模型], [TCP/IP 模型], [功能],
    [应用层], table.cell(rowspan: 2)[应用层], [应用],
    [表示层], [数据表示, 格式转换, 加解密],
    [会话层], table.cell(rowspan: 2)[传输层], [管理两个端点的通信, 建立, 维护, 拆除会话],
    [传输层], [端点(不一定是主机)间的数据段传输],
    [网络层], [网络层], [路由],
    [链路层], table.cell(rowspan: 2)[网络接口层], [可靠帧传输],
    [物理层], [透明比特流传输],
  )


= 物理层
透明传输比特流.

#problem[
  在一根有传输延迟为 5ms 的 4Mbps 链路上发送 500 字节的消息, 此消息从发送到传播至目的地的延迟共有多少?
  #solution[
    链路的吞吐量(带宽)决定了发送数据的速度, 延迟决定了最后一个数据包从发出到到达的时延, 于是
    $
      L = M/R + D = (500 Bytes)/(4 Mbps) + 5 ms =6 ms
    $
  ]
]

#problem[
  在一个传播延迟为 4ms 的 5Mbps 互联网访问链路上, 传输数据最大数量是多少?
  #solution[
    这里的"传播延迟"其实是"可以容忍的从首个数据发出到最后一个数据接收之间的时间", 所以
    $
      "BD" = R D = 5 Mbps dot 4 ms = 2500 Bytes
    $
  ]
]

#problem[
  1bit在一个传输速度为 1 Gbps 的有线网络上可以传播多远? 假设通过线传播的信号的传播速度是真空中光速的 $2 slash 3$.
  #solution[
    其实是想问"最后一个数据发出时, 第一个发出的数据已经传播了多远", 于是
    $
      (1 bit)/(1 Gbps) dot 2/3 dot c = 20 "cm"
    $
  ]
]


== 信道的最大数字带宽
#theorem(title: [奈奎斯特定理])[
  显然超过 $S_max$ 的采样率没有意义, 所以没有噪声的理想信道的数字带宽上限是
  $
    R_max = S_max dot log_2 L
  $
  其中
  $
    S_max = 2 times B
  $
  是最大采样率, 是每秒采样的次数, $B$ 是频带范围, $L$ 是信号的离散级别, 比如采样两个二进制位, 则 $L = 2^2 = 4$.
]

#theorem(title: [香农定理])[
  在有噪声的信道里, 有
  $
    R_max = B times log_2 (1 + S slash N)
  $
  其中 $S slash N$ 是信噪比, 当其单位为分贝时, 有
  $
    S slash N ("db") = 10 times log_10 S slash N
  $
]

#problem[
  有一条4 kHz的无噪声信道, 每秒采样8000次, 如果每个采样是
  16比特, 则信道的最大传输速率是?
  #solution[
    其实我们不关心他实际上每秒采样多少次, 只关心信道本身的性质.
    $
      R_max = 2 dot 4000 dot 16 = 128 kbps
    $
  ]
]

#problem[
  如果一个二进制信号通过一条 4 kHz的噪声信道, 噪声是30分贝, 则最大传输速率是?
  #solution[
    $
      R_max = 4000 dot log_2 (1 + 1000) approx 40 kbps
    $
  ]
]

#problem[
  如果一条信道的带宽在 3MHz和4MHz之间, 且信噪比是24分贝, 问:
  + 信道的传输能力(最大传输速度)如何?
  + 为了达到这个传输能力, 信号级别需要多少级?
  #solution[
    注意两个公式里面的 $B$ 都是频带范围, 所以这里的 $B$ 应该是
    $
      B = 4 MHz - 3 MHz = 1 MHz
    $
    + $
        S slash N = 10^(24/10) \
        R_max = B log_2 (1 + S slash N) approx 8 Mbps
      $
    + $
        R_max < 2 B log_2 L => L >= 16
      $
  ]
]


== 编码和调制
- 编码: 对数字信号
  - 归零: 正负电平, 发送完回到 0
  - 非归零: 正电平和负电平
  - 非归零逆转: 传输 0 时逆转信号, 传输1时不变
  - 曼彻斯特: 使用向上, 向下跳变行为编码 0, 1
  - $x$b/$y$b 编码: 用 $y$ 位前缀码编码 $x$ 位数据.
- 调制: 对模拟信号
  - 调幅
  - 调频
  - 调相
  - 综合调制: QAM-$n$ 代表有 $n$ 个信号级别, 每个码元表示 $log_2 n$ 比特数据


== 复用
在单个信道中传输多个信号.
- 时分复用 TDM: 在小的时间片上轮流使用信道. 一种方法是均分, 还可以使用统计时分复用(STDM)的方法根据用户需求分配时间片.
- 频分复用 FDM: 把物理带宽分为若干频率范围, 形成子频带和子信道, 子信道之间可以有很窄的保护带. 计算子信道带宽时, 直接用总带宽除以子信道数量. 有一种技术是正交频分复用(OFDM), 相邻信号必须正交, 但是信道可以重叠, 从而能提升信道的总带宽.
- 波分复用 WDM: 光信号的FDM.
- 码分复用 CDM: 把每个连接的一个比特分为到 $m$ 个时间间隔中发送, 这些离散的时间是*码片*, 把 1 编码为 $m$ 维的双极向量(分量为 $plus.minus 1$), 称为*码片序列*. 所有用户的码片序列两两正交, 所以可以全都混在一起线性叠加地发送, 接收方只需要用自己的码片和接收的叠加信号点积, 观察结果 ($m$, $0$, $-m$) 就能得知发送内容.

#problem[
  五个用户使用 TDM 或 FDM 共享1 Mbps 链路. 使用 TDM的每个用户都要以一个固定的顺序轮流完全占据链接 1 ms. 使用FDM的每个用户在所有时间中获得 1/5 的链路. 当用户传输一个 1250 字节的消息时, 哪个方法具有最低的可能延迟, 且该延迟时间是多少?
  #solution[
    - TDM: 每个 1ms 内可以发送
      $
        1 ms dot 1 Mbps = 125 Bytes
      $
      故共需要等待 9 个 $4 ms$ 和发送 10 个 $10 ms$, 共 $46 ms$.
    - FDM:
      $
        (1250 Bytes)/((1 Mbps)/5) = 50 ms
      $
    故为 TDM, 46 ms.
  ]
]

== 介质
- 同轴电缆
- 双绞线
  #table(
    columns: 3,
    [], [屏蔽双绞线 STP], [非屏蔽双绞线 UTP],
    [外屏蔽层], [有], [有],
    [线对屏蔽层], [有], [无],
    [尺寸], [大], [小],
    [重量], [重], [轻],
    [安装], [难], [易],
    [特点], [], [局域网中广泛使用],
  )
- 光纤: 光纤中不同入射角的光线可以互不干扰地传播, 每个入射角是一个"模式", 因此有多模光纤和单模光纤.
  #table(
    columns: 3,
    [], [单模光纤], [多模光纤],
    [发光器件], [半导体激光器], [发光二极管],
    [发光器件价格], [贵], [便宜],
    [发光器件寿命], [短], [长],
    [传输距离], [长], [短],
    [带宽], [大], [小],
    [芯线], [细], [粗],
  )
- 非导引性介质, 如微波

= 链路层
负责把数据打包成帧, 并做纠错和流量控制.


== 成帧
- 字节计数法: 帧头标记这一帧多大, 但是第一帧错了就全完了.
- 带字节填充的字节标记法: 用一个特定的定界符 FLAG(一个特殊字节) 来标记首尾. 包长度只能是字节为单位, 如果包中间也出现了 FLAG 就要用特定的转义符ESC (也是一个特殊字节)转义, ESC自身也转义.
- 带位填充的位标志法: 允许一帧为任意长度. 起始和终止标志是 01111110(中间有6个1), 但是中间如果发送了五个连续的1, 就会强制发送一个 0, 所以永远都不会重复. 接收方收信的时候碰到五个1接一个0就会把0删掉.
- 物理层编码违例: 如果物理层用跳变编码 0 和 1, 那可以留出来连续高(低)电平定界.


== 检错和纠错
=== 奇偶校验
通过在数据后 append 一位, 保证整个帧的所有 1 的个数是奇数或者偶数.


=== CRC
- 发方
  + 约定 $r$ 阶多项式 $G=sum_(i = 0)^r g_i x^i$, 其中 $g_i in {0, 1}$, 于是可以仅取系数表示为 $r+1$ 位二进制数 $G$, 高阶对应高位.
  + 对数据 $M$, 左移 $r$ 位, 也即 $x^r M$.
  + 作模二除法 $x^r M slash G$ 余数为 $c$
    - 二进制除法中直接使用异或作为加减法, 不需要试商, "够除"只看位数
  + 把 $r$ append 上 $c$, 作为真实发送的数据
- 收方
  + 对收到的信息作模二除法查看是否能被 $G$ 整除, 若不能则出错, 若能则无错.

#problem[
  用标准 CRC 方法来传输位流 10011101. 生成多项式为 $x^3+1$.
  + 试问实际被传输的位串是什么?
  + 假设在传输过程中从左边数第三位变反了. 请说明这个错误可以在接收端能否被检测出来.
  + 给出一个该比特流传输错误的实例, 使得接受方无法检测出该错误.
  #solution[
    $
      G = 1001
    $
    + 有
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          [], [ ], [1], [0], [0], [0], [1], [1], [0], [0], [1], [0], [0],
          table.hline(start: 1),
          [1001], $)$, [1], [0], [0], [1], [1], [1], [0], [1], [0], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 10),
          [], [ ], [0], [0], [0], [0], [1], [1], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [],
          table.hline(start: 6, end: 11),
          [], [ ], [ ], [ ], [ ], [ ], [0], [1], [0], [0], [0], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [],
          table.hline(start: 7, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [1], [0], [0],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0],
        )
      })
    故为 10011101100.
    + 若第三位取反, 也即接收到 10111101100, 则
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          [], [ ], [1], [0], [1], [0], [1], [0], [0], [0], [0], [0], [0],
          table.hline(start: 1),
          [1001], $)$, [1], [0], [1], [1], [1], [1], [0], [1], [1], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 8),
          [], [ ], [0], [0], [1], [0], [1], [1], [], [], [], [], [],
          [], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [], [ ], [ ],
          table.hline(start: 4, end: 10),
          [], [ ], [ ], [ ], [0], [0], [1], [0], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [ ],
          table.hline(start: 6, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [0], [1], [0], [0],
        )
      })
      余数不为 0, 故检测到出错.
    + 只需要令正确数据再异或(加)上除数即可
      $
        10011101100 xor 1001 = 10011100101
      $
  ]
]

=== 互联网校验和
+ 发送方: 把数据按一定比特长度分为多个位串, 然后执行反码求和, 得到的即为校验和
+ 接收方: 把收到的数据按同样方式分为多个位串, 把这些位串和校验和做反码求和, 得到 0 即为无错误, 得到 1 则为有错误.

=== 纠1位错的海明码
两个位串中不同的位的个数为这两个位串的海明距离(也即 xor 后统计 1 的个数).

一个编码中任取两个码字, 最小的海明距离就是这个编码的海明距离.

海明距离为 $d + 1$ 的编码方案能实现 $d$ 位的错误检测, 因为只有 $d + 1$ 位同时发生错误才有可能不被察觉地从一个编码变为另一个.

令码字长度
$
  n = m + r
$
求出最小 $r$ 满足
$
  m + r + 1 <= 2^r
$

这 $n$ 位中 $r$ 位是校验码, 分布在从第一位开始的 2 的幂次位上.

编码时, 把原数据每一位的序号分解为 2 的幂的和. 然后对于每一个2的幂位置的校验码, 取出所有分解包含该位置序号的位, 把这些位异或(或者做奇偶校验)就能得到这个校验码的值.

解码时, 按编码的方式重新计算校验位, 并且统计所有不一致的校验位. 如果全都一致, 那么认为没有错误, 如果有不一致, 把所有出错校验位的序号加起来就是出错的实际位的序号, 把那一位取反即可.

#problem[
  偶校验纠1位错海明码编码 10101111.

  #solution[
    $
      m = 8 \
      m + r + 1 <= 2^r => r >= 4
    $
    使用 4 位纠错码, 则
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], [], [], [1], [], [0], [1], [0], [], [1], [1], [1], [1],
      [纠错码1], [1], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [0], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], .."101001001111".clusters(),
    )
  ]
]

#problem[
  偶校验纠 1 位错海明码纠错 100110001100, 其中 $m = 8$, $r = 4$.
  #solution[
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], .."100110001100".clusters(),
      [纠错码1], [0], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [1], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [1], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], sym.crossmark, sym.crossmark, [], sym.checkmark, [], [], [], sym.checkmark,
    )
    故第 $1 + 2 = 3$ 位出错, 取反, 正确值为 101110001100.
  ]
]

== 可靠传输
=== 停等
接收方收到正确数据返回一个确认帧 ACK, 否则什么都不发. 发送方收到确认帧就发下一帧, 若长时间没有收到就重传这一帧(ARQ, 自动重复请求协议).

由于是一帧一帧地发, 所以只需要一位二进制标识帧号, 在发送和确认时传送.

信道利用率
$
  "util" = T_"data" / (T_"data" + T_"ACK" + 2 l)
$
常常认为 $T_"ACK"$ 为 0, 因为比较小. $l$ 为延迟.

#problem[
  使用 ARQ 协议在一个 1 Mbps 链路上发送一系列的 1250 字节消息. 此链路的传播延迟为 5 ms. 问可以使用的链路带宽的最大百分比是多少?
  #solution[
    $
      T_"data" = (1250 Bytes)/(1 Mbps) = 10 ms \
      "util" = (10 ms)/(10 ms + 2 dot 5 ms) = 50%
    $
  ]
]

=== 滑动窗口
同时进行 $w$ 个停等.

信道利用率
$
  "util" =(w T_"data") / (T_"data" + T_"ACK" + 2 l)
$

可以看出只要窗口够大, 热身后利用率就能达到 $100%$.

出错时有两种方案
+ 回退 n 帧 GBN: 从出错那帧(没收到 ACK 开始)全部重发, 需要发送方有较大缓冲区, 因为发送方需要重传. 窗口最大为 $"MAX_SEQ"$, MAX_SEQ 为最大序列号(从 0 开始). 可以结合无滑动窗口的情况记忆, 也即序号从 0 开始, 最大为 1 , 窗口也为 1 .
+ 选择性重传: 只重传出错的帧, 需要接收方有较大缓冲区, 因为要等待和排序收到的帧. 窗口最大为 $("MAX_SEQ" + 1) slash 2$

这种最大窗口区别的本质是回退 n 帧的渐进的, 即使只确认了一个也能向下滑动, 而选择性重传是累计的, 本窗口必须全部完成才能向下滑动. 因此回退n帧只需要提供 1 的冗余, 而选择性重传需要提供一个完整窗口的冗余.

#problem[
  两台主机之间的数据链路层采用了回退 n 帧协议(GBN)传输数据, 数据传输速率为 16 kbps, 单向传播延迟是 270 ms, 数据帧长度为 128 - 512B, 接收方总是以数据帧等长的帧进行确认, 为使得信道利用率达到最高, 帧序号的比特数至少为多少位?
  #solution[
    要求至少, 所以我们求上界, 取数据帧长度 128 Bytes.
    $
      T_"data" = T_"ACK" = (128 Bytes)/(16 Kbps) = 64 ms \
      "util" = w (64 ms)/(2 dot 64 ms + 2 dot 270 ms) => w > 10
    $
    取 $w = 11$, 则帧序号至少有 $0 ~ 11$, 也即至少 4 位.
  ]
]

...to be done
