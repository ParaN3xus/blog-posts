#import "@preview/numbly:0.1.0": numbly
#import "@preview/theorion:0.3.3": *
#import cosmos.rainbow: *

#import "/typ/templates/blog.typ": *

#show: main.with(
  title: "计算机网络复习笔记",
  desc: [计算机网络复习笔记],
  date: "2025-06-25",
  tags: (
    blog-tags.network,
  ),
  license: licenses.cc-by-nc-sa,
)


#let (problem-counter, problem-box, problem, show-problem) = make-frame(
  "problem",
  "例",
  inherited-levels: 1,
  inherited-from: heading,
  render: render-fn.with(fill: rgb("#1F2421")),
)

#let (solution-counter, solution-box, solution, show-solution) = make-frame(
  "solution",
  "解",
  inherited-levels: 1,
  inherited-from: heading,
  numbering: _ => { (..x) => {} },
  render: render-fn.with(fill: rgb("216869")),
)

#show: show-theorion
#show: show-problem
#show: show-solution

#show: x => context if shiroa-sys-target() == "paged" {
  set page(numbering: "1")
  show table: it => align(center, it)
  show table: block.with(width: 100%)
  show math.equation: block.with(width: 100%)
  x
} else {
  x
}

#let Bytes = "Bytes"
#let Kbps = "Kbps"
#let Mbps = "Mbps"
#let Gbps = "Gbps"
#let kbps = "kbps"
#let ms = "ms"
#let MHz = "MHz"
#let bit = "bit"
#let bits = "bits"

#context if shiroa-sys-target() == "paged" {
  outline(depth: 2)
}


= 绪论
将自治的计算机相互连接在一起的系统称为计算机网络.

按照地理范围递增, 网络包括
- PAN 个域网
- LAN 局域网
- MAN 城域网
- WAN 广域网

- 单位:
  - 字节: 大 B, 存储介质中存储的数据量
  - 比特: 小 b, 吞吐量
- 参考模型: OSI 七层, TCP/IP 四层
  #table(
    columns: 3,
    align: center + horizon,
    [OSI 模型], [TCP/IP 模型], [功能],
    [应用层], table.cell(rowspan: 2)[应用层], [应用],
    [表示层], [数据表示, 格式转换, 加解密],
    [会话层], table.cell(rowspan: 2)[传输层], [管理两个端点的通信, 建立, 维护, 拆除会话],
    [传输层], [端点(不一定是主机)间的数据段传输],
    [网络层], [网络层], [路由],
    [链路层], table.cell(rowspan: 2)[网络接口层], [可靠帧传输],
    [物理层], [透明比特流传输],
  )

ICANN 管理 IP 地址资源分配和顶级域名, 前身是 IANA. ICANN

ISOC 是互联网协会, 下辖
- IAB: 互联网结构委员会
- IETF: 制定互联网标准的, 解决实际的工程问题
- IRTF: 互联网技术研究
- 等
认为 IETF 和 IRTF 是 IAB 的下属.

通信子网中只有两种元素: 网络节点和通信链路.

服务和协议是完全相分离的, 于是能自由更改协议而不影响提供的服务.

IEEE 802 包括
- 802.1: 网络互连
  - 802.1Q: VLAN
  - 802.1X: 基于端口的网络访问控制
  - 802.1D: 生成树协议STP
- 802.2: 逻辑链路控制 LLC
- 802.3: 以太网
- 802.11: 无线局域网 WiFi


= 物理层
透明传输比特流.

#problem[
  在一根有传输延迟为 5ms 的 4Mbps 链路上发送 500 字节的消息, 此消息从发送到传播至目的地的延迟共有多少?
  #solution[
    链路的吞吐量(带宽)决定了发送数据的速度, 延迟决定了最后一个数据包从发出到到达的时延, 于是
    $
      L = M/R + D = (500 Bytes)/(4 Mbps) + 5 ms =6 ms
    $
  ]
]

#problem[
  在一个传播延迟为 4ms 的 5Mbps 互联网访问链路上, 传输数据最大数量是多少?
  #solution[
    这里的"传播延迟"其实是"可以容忍的从首个数据发出到最后一个数据接收之间的时间", 所以
    $
      "BD" = R D = 5 Mbps dot 4 ms = 2500 Bytes
    $
  ]
]

#problem[
  1bit在一个传输速度为 1 Gbps 的有线网络上可以传播多远? 假设通过线传播的信号的传播速度是真空中光速的 $2 slash 3$.
  #solution[
    其实是想问"最后一个数据发出时, 第一个发出的数据已经传播了多远", 于是
    $
      (1 bit)/(1 Gbps) dot 2/3 dot c = 20 "cm"
    $
  ]
]


== 信道的最大数字带宽
数字带宽是理想的, 静态的, 而吞吐量是实际可测得的.

#theorem(title: [奈奎斯特定理])[
  显然超过 $S_max$ 的采样率没有意义, 所以没有噪声的理想信道的数字带宽上限是
  $
    R_max = S_max dot log_2 L
  $
  其中
  $
    S_max = 2 times B
  $
  是最大采样率, 是每秒采样的次数, $B$ 是频带范围, $L$ 是信号的离散级别, 比如采样两个二进制位, 则 $L = 2^2 = 4$.
]

#theorem(title: [香农定理])[
  在有噪声的信道里, 有
  $
    R_max = B times log_2 (1 + S slash N)
  $
  其中 $S slash N$ 是信噪比, 当其单位为分贝时, 有
  $
    S slash N ("db") = 10 times log_10 S slash N
  $
]

#problem[
  有一条4 kHz的无噪声信道, 每秒采样8000次, 如果每个采样是
  16比特, 则信道的最大传输速率是?
  #solution[
    其实我们不关心他实际上每秒采样多少次, 只关心信道本身的性质.
    $
      R_max = 2 dot 4000 dot 16 = 128 kbps
    $
  ]
]

#problem[
  如果一个二进制信号通过一条 4 kHz的噪声信道, 噪声是30分贝, 则最大传输速率是?
  #solution[
    $
      R_max = 4000 dot log_2 (1 + 1000) approx 40 kbps
    $
  ]
]

#problem[
  如果一条信道的带宽在 3MHz和4MHz之间, 且信噪比是24分贝, 问:
  + 信道的传输能力(最大传输速度)如何?
  + 为了达到这个传输能力, 信号级别需要多少级?
  #solution[
    注意两个公式里面的 $B$ 都是频带范围, 所以这里的 $B$ 应该是
    $
      B = 4 MHz - 3 MHz = 1 MHz
    $
    + $
        S slash N = 10^(24/10) \
        R_max = B log_2 (1 + S slash N) approx 8 Mbps
      $
    + $
        R_max < 2 B log_2 L => L >= 16
      $
  ]
]


== 编码和调制
- 编码: 对数字信号
  - 归零: 正负电平, 发送完回到 0
  - 非归零NRZ: 正电平和负电平
  - 非归零逆转NRZI: 传输 0 时逆转信号, 传输1时不变
  - 曼彻斯特: 使用向上, 向下跳变行为编码 0, 1
  - $x$b/$y$b 编码: 用 $y$ 位前缀码编码 $x$ 位数据.
- 调制: 对模拟信号
  - 调幅
  - 调频
  - 调相
  - 综合调制: QAM-$n$ 代表有 $n$ 个信号级别, 每个码元表示 $log_2 n$ 比特数据

信号经过傅里叶肥西可以分解成不同频率的谐波, 谐波的频率是基频的整数倍.

== 复用
在单个信道中传输多个信号.
- 时分复用 TDM: 在小的时间片上轮流使用信道. 一种方法是均分, 还可以使用统计时分复用(STDM)的方法根据用户需求分配时间片.
- 频分复用 FDM: 把物理带宽分为若干频率范围, 形成子频带和子信道, 子信道之间可以有很窄的保护带. 计算子信道带宽时, 直接用总带宽除以子信道数量. 有一种技术是正交频分复用(OFDM), 相邻信号必须正交, 但是信道可以重叠, 从而能提升信道的总带宽.
- 波分复用 WDM: 光信号的FDM.
- 码分复用 CDM: 把每个连接的一个比特分为到 $m$ 个时间间隔中发送, 这些离散的时间是*码片*, 把 1 编码为 $m$ 维的双极向量(分量为 $plus.minus 1$), 称为*码片序列*. 所有用户的码片序列两两正交, 所以可以全都混在一起线性叠加地发送, 接收方只需要用*发送方*的码片和接收的叠加信号点积, 观察结果 ($m$, $0$, $-m$) 就能得知发送内容.

#problem[
  五个用户使用 TDM 或 FDM 共享1 Mbps 链路. 使用 TDM的每个用户都要以一个固定的顺序轮流完全占据链接 1 ms. 使用FDM的每个用户在所有时间中获得 1/5 的链路. 当用户传输一个 1250 字节的消息时, 哪个方法具有最低的可能延迟, 且该延迟时间是多少?
  #solution[
    - TDM: 每个 1ms 内可以发送
      $
        1 ms dot 1 Mbps = 125 Bytes
      $
      故共需要等待 9 个 $4 ms$ 和发送 10 个 $10 ms$, 共 $46 ms$.
    - FDM:
      $
        (1250 Bytes)/((1 Mbps)/5) = 50 ms
      $
    故为 TDM, 46 ms.
  ]
]

== 介质
- 同轴电缆
- 双绞线
  #table(
    columns: 3,
    [], [屏蔽双绞线 STP], [非屏蔽双绞线 UTP],
    [外屏蔽层], [有], [有],
    [线对屏蔽层], [有], [无],
    [尺寸], [大], [小],
    [重量], [重], [轻],
    [安装], [难], [易],
    [特点], [], [局域网中广泛使用],
  )
- 光纤: 光纤中不同入射角的光线可以互不干扰地传播, 每个入射角是一个"模式", 因此有多模光纤和单模光纤.
  #table(
    columns: 3,
    [], [单模光纤], [多模光纤],
    [发光器件], [半导体激光器], [发光二极管],
    [发光器件价格], [贵], [便宜],
    [发光器件寿命], [短], [长],
    [传输距离], [长], [短],
    [带宽], [大], [小],
    [芯线], [细], [粗],
  )
- 非导引性介质, 如微波. 微波容易发生多径衰落.

有线介质传播距离: $"光纤" > "同轴电缆" > "屏蔽双绞线" > "非屏蔽双绞线"$.

== PSTN
#table(
  columns: (auto, auto, auto, auto),
  align: horizon,
  [等级], [速率 (Mbps)], [路数], [说明],

  table.cell(colspan: 4)[Ex系列(欧洲/中国标准)],
  [E1], [2.048], [30], [],
  [E2], [8.448], [120], [4 倍 E1],
  [E3], [34.368], [480], [4 倍 E2],
  [E4], [139.264], [1920], [4 倍 E3],
  [E5], [565.148], [7680], [4 倍 E4],

  table.cell(colspan: 4)[Tx系列(北美/日本标准)],
  [T1], [1.544], [24], [],
  [T2], [6.312], [96], [4 倍 T1],
  [T3], [44.736], [672], [7 倍 T2],
  [T4], [274.176], [4032], [6 倍 T3],
)


== 设备
- 放大器: 去噪和放大信号, 多用于总线拓扑
- 集线器: 收到信号广播给其他所有节点, 多用于星形拓扑. 现在已经基本不用了

= 链路层
负责把数据打包成帧, 并做纠错和流量控制.

包括 MAC(介质访问控制) 子层和 LLC(逻辑链路控制) 子层.

== 成帧
- 字节计数法: 帧头标记这一帧多大, 但是第一帧错了就全完了.
- 带字节填充的字节标记法: 用一个特定的定界符 FLAG(一个特殊字节) 来标记首尾. 包长度只能是字节为单位, 如果包中间也出现了 FLAG 就要用特定的转义符ESC (也是一个特殊字节)转义, ESC自身也转义.
- 带位填充的位标志法: 允许一帧为任意长度. 起始和终止标志是 01111110(中间有6个1), 但是中间如果发送了五个连续的1, 就会强制发送一个 0, 所以永远都不会重复. 接收方收信的时候碰到五个1接一个0就会把0删掉.
- 物理层编码违例: 如果物理层用跳变编码 0 和 1, 那可以留出来连续高(低)电平定界.


== 检错和纠错
数据传输可能出现错误, 主要有突发错误和随机错误.

=== 奇偶校验
通过在数据后 append 一位, 保证整个帧的所有 1 的个数是奇数或者偶数.

能检一位错, 海明距离是偶数.


=== CRC
- 发方
  + , 定 $r$ 阶多项式 $G=sum_(i = 0)^r g_i x^i$, 其中 $g_i in {0, 1}$, 于是可以仅取系数表示为 $r+1$ 位二进制数 $G$, 高阶对应高位.
  + 对数据 $M$, 左移 $r$ 位, 也即 $x^r M$.
  + 作模二除法 $x^r M slash G$ 余数为 $c$
    - 二进制除法中直接使用异或作为加减法, 不需要试商, "够除"只看位数
  + 把 $r$ append 上 $c$, 作为真实发送的数据
- 收方
  + 对收到的信息作模二除法查看是否能被 $G$ 整除, 若不能则出错, 若能则无错.

#problem[
  用标准 CRC 方法来传输位流 10011101. 生成多项式为 $x^3+1$.
  + 试问实际被传输的位串是什么?
  + 假设在传输过程中从左边数第三位变反了. 请说明这个错误可以在接收端能否被检测出来.
  + 给出一个该比特流传输错误的实例, 使得接受方无法检测出该错误.
  #solution[
    $
      G = 1001
    $
    + 有
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          table.hline(start: 1),
          [1001], $)$, [1], [0], [0], [1], [1], [1], [0], [1], [0], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 10),
          [], [ ], [0], [0], [0], [0], [1], [1], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [],
          table.hline(start: 6, end: 11),
          [], [ ], [ ], [ ], [ ], [ ], [0], [1], [0], [0], [0], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [],
          table.hline(start: 7, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [1], [0], [0],
          [], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [ ], [1], [0], [0],
        )
      })
    故为 10011101100.
    + 若第三位取反, 也即接收到 10111101100, 则
      #auto-div-frame(theme => {
        set table.hline(stroke: 0.5pt + theme.main-color)
        table(
          columns: 13,
          stroke: none,
          table.hline(start: 1),
          [1001], $)$, [1], [0], [1], [1], [1], [1], [0], [1], [1], [0], [0],
          [], [ ], [1], [0], [0], [1], [], [], [], [], [], [], [],
          table.hline(start: 2, end: 8),
          [], [ ], [0], [0], [1], [0], [1], [1], [], [], [], [], [],
          [], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [], [ ], [ ],
          table.hline(start: 4, end: 10),
          [], [ ], [ ], [ ], [0], [0], [1], [0], [0], [1], [], [], [],
          [], [ ], [ ], [ ], [ ], [ ], [1], [0], [0], [1], [], [], [ ],
          table.hline(start: 6, end: 14),
          [], [ ], [ ], [ ], [ ], [ ], [0], [0], [0], [0], [1], [0], [0],
        )
      })
      余数不为 0, 故检测到出错.
    + 只需要令正确数据再异或(加)上除数即可
      $
        10011101100 xor 1001 = 10011100101
      $
  ]
]

=== 互联网校验和
+ 发送方: 把数据按一定比特长度分为多个位串, 然后执行反码求和, 得到的即为校验和
+ 接收方: 把收到的数据按同样方式分为多个位串, 把这些位串和校验和做反码求和, 得到 0 即为无错误, 得到 1 则为有错误.

反码求和也即先求和, 溢出部分当作加数继续求和, 直到没有溢出后, 对结果取反.

=== 纠1位错的海明码
两个位串中不同的位的个数为这两个位串的海明距离(也即 xor 后统计 1 的个数).

一个编码中任取两个码字, 最小的海明距离就是这个编码的海明距离.

海明距离为 $d + 1$ 的编码方案能实现 $d$ 位的错误检测, 因为只有 $d + 1$ 位同时发生错误才有可能不被察觉地从一个编码变为另一个.

令码字长度
$
  n = m + r
$
求出最小 $r$ 满足
$
  m + r + 1 <= 2^r
$

这 $n$ 位中 $r$ 位是校验码, 分布在从第一位开始的 2 的幂次位上.

编码时, 把原数据每一位的序号分解为 2 的幂的和. 然后对于每一个2的幂位置的校验码, 取出所有分解包含该位置序号的位, 把这些位异或(或者做奇偶校验)就能得到这个校验码的值.

解码时, 按编码的方式重新计算校验位, 并且统计所有不一致的校验位. 如果全都一致, 那么认为没有错误, 如果有不一致, 把所有出错校验位的序号加起来就是出错的实际位的序号, 把那一位取反即可.

#problem[
  偶校验纠1位错海明码编码 10101111.

  #solution[
    $
      m = 8 \
      m + r + 1 <= 2^r => r >= 4
    $
    使用 4 位纠错码, 则
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], [], [], [1], [], [0], [1], [0], [], [1], [1], [1], [1],
      [纠错码1], [1], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [0], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], .."101001001111".clusters(),
    )
  ]
]

#problem[
  偶校验纠 1 位错海明码纠错 100110001100, 其中 $m = 8$, $r = 4$.
  #solution[
    #table(
      columns: (5em,) + (1.5em,) * 12,
      [序号], ..range(1, 13).map(str),
      [值], .."100110001100".clusters(),
      [纠错码1], [0], [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [], sym.checkmark, [],
      [纠错码2], [], [1], sym.checkmark, [], [], sym.checkmark, sym.checkmark, [], [], sym.checkmark, sym.checkmark, [],
      [纠错码4], [], [], [], [1], sym.checkmark, sym.checkmark, sym.checkmark, [], [], [], [], sym.checkmark,
      [纠错码8], [], [], [], [], [], [], [], [0], sym.checkmark, sym.checkmark, sym.checkmark, sym.checkmark,
      [结果], sym.crossmark, sym.crossmark, [], sym.checkmark, [], [], [], sym.checkmark,
    )
    故第 $1 + 2 = 3$ 位出错, 取反, 正确值为 101110001100.
  ]
]


== 可靠传输

=== 停等
接收方收到正确数据返回一个确认帧 ACK, 否则什么都不发. 发送方收到确认帧就发下一帧, 若长时间没有收到就重传这一帧(ARQ, 自动重复请求协议).

由于是一帧一帧地发, 所以只需要一位二进制标识帧号, 在发送和确认时传送.

信道利用率
$
  "util" = T_"data" / (T_"data" + T_"ACK" + 2 l)
$
常常认为 $T_"ACK"$ 为 0, 因为比较小. $l$ 为延迟.

#problem[
  使用 ARQ 协议在一个 1 Mbps 链路上发送一系列的 1250 字节消息. 此链路的传播延迟为 5 ms. 问可以使用的链路带宽的最大百分比是多少?
  #solution[
    $
      T_"data" = (1250 Bytes)/(1 Mbps) = 10 ms \
      "util" = (10 ms)/(10 ms + 2 dot 5 ms) = 50%
    $
  ]
]

=== 滑动窗口
同时进行 $w$ 个停等.

信道利用率
$
  "util" =(w T_"data") / (T_"data" + T_"ACK" + 2 l)
$

可以看出只要窗口够大, 热身后利用率就能达到 $100%$.

出错时有两种方案
+ 回退 n 帧 GBN: 从出错那帧(没收到 ACK 开始)全部重发, 需要发送方有较大缓冲区, 因为发送方需要重传. 发送窗口最大为 $"MAX_SEQ"$, MAX_SEQ 为最大序列号(从 0 开始), 接收窗口固定为 1. 可以结合无滑动窗口的情况记忆, 也即序号从 0 开始, 最大为 1 , 窗口也为 1 .
+ 选择性重传: 只重传出错的帧, 需要接收方有较大缓冲区, 因为要等待和排序收到的帧. 窗口最大为 $("MAX_SEQ" + 1) slash 2$

这种最大窗口区别的本质是回退 n 帧的渐进的, 即使只确认了一个也能向下滑动, 而选择性重传是累计的, 本窗口必须全部完成才能向下滑动. 因此回退n帧只需要提供 1 的冗余, 而选择性重传需要提供一个完整窗口的冗余.

选择性重传不需要重传大量帧, 效率比较高.

#problem[
  两台主机之间的数据链路层采用了回退 n 帧协议(GBN)传输数据, 数据传输速率为 16 kbps, 单向传播延迟是 270 ms, 数据帧长度为 128 - 512B, 接收方总是以数据帧等长的帧进行确认, 为使得信道利用率达到最高, 帧序号的比特数至少为多少位?
  #solution[
    要求至少, 所以我们求上界, 取数据帧长度 128 Bytes.
    $
      T_"data" = T_"ACK" = (128 Bytes)/(16 Kbps) = 64 ms \
      "util" = w (64 ms)/(2 dot 64 ms + 2 dot 270 ms) => w > 10
    $
    取 $w = 11$, 则帧序号至少有 $0 ~ 11$, 也即至少 4 位.
  ]
]

== 数据链路控制(LCP)协议
=== HDLC
带位填充的位标志法成帧, CRC 检错.

链路控制功能包括连接的建立, 数据的传输, 连接的断开.

=== PPP

=== PPPoE

= 介质访问控制和局域网
一条信道需要被许多工作站共享, 因此需要考虑信道的分配和使用, 这就是 MAC 介质访问控制, 这部分功能由 MAC 层完成.

局域网信道包括
- 广播式信道: 所有节点共享一条信道, 只有这种情况才需要解决冲突的介质访问控制方法, 注意不一定是总线拓扑, 如环状也许要
- 点对点信道: 两个节点专用的通信链路

== 多路访问协议
目的是为了让每台工作站都有信道的部分使用权. 分为
- 随机访问协议
- 受控访问协议
- 有限竞争协议

=== 随机访问协议
工作站不是提前获得预分配的资源, 而是有了要传输的数据帧之后, 用一种机制竞争共享信道的使用权.

==== 纯 ALOHA 协议
"任性", 所有计算机想发就发.
- 如果发送成功, 接收站回一个确认帧, 网络中有一个特殊计算机会把收到的确认帧广播出去, 发送站收到了确认帧就认为发送成功.
- 如果同时有两台计算机在发送信息, 就会发生碰撞, 发送失败, 无法通过 CRC 校验, 于是会遵循二进制指数回退算法进行重传.

#definition(title: "二进制指数回退算法(BEB)")[
  第 $k$ 次传输失败, 从 $[0, 2^k- 1]$ 中随机抽一个时间等待后再重发.
]

#theorem[
  ALOHA 协议的吞吐量为
  $
    S = G e^(-2G)
  $
  其中 $G$ 是每个标准帧时(传输一个数据帧需要的时间)内产生和重传的平均数据帧数.
]

==== 分槽 ALOHA 协议
把时间离散化, 存在某些同步的时隙的开始, 只有在开始处才能发信.

#theorem[
  分槽 ALOHA 协议的吞吐量为
  $
    S = G e^(-G)
  $
]

==== 载波侦听多路访问(CSMA, Carrier Sense Multiple Access)系列
===== 非持续 CSMA
要发信的时候先侦听信道是否在使用, 如果在用, 就先等待一个随机时间再来, 如果没在用, 就发.

===== $p$-持续 CSMA
要发信的时候先侦听信道是否在使用, 如果在用, 那就一直监听, 直到空闲. 如果发现空闲, 有概率 $p$ 发信, $1-p$ 空出一个时隙再监听.

===== 1-持续 CSMA
$p$-持续 CSMA 的一种特例.

===== 带冲突检测的 CSMA (CSMA/CD)
即使使用上述策略, 还是有冲突的可能.

CSMA/CD 的网卡有发送器Tx和接收器Rx, Tx发信的时候也给Rx一份, Rx同时也会监听网络上的信号, 如果Rx监听到两个信号一样, 就说明没冲突, 如果检测到冲突, 就停止发送, 并且广播一个拥塞信号 jam.

冲突只能在开始发送后 $2D$ ($D$ 是最远的一台机器的时延)时间内发生, 这是显然的: 极端情况本机消息的头部与另一条消息的头部发生碰撞并被最远的一台机器检测到, 其广播 jam 并被本机接收. 这个时间是冲突窗口, 只要在这个时间内没有检测到冲突, 就说明发送成功.

同时, $2D$ 也是最小帧长, 因为如果比此长度还短, 即使检测到冲突, 消息也已经发完了.

经典以太网使用 CSMA/CD, 除此了上面描述的之外, 还有以下设计
- 检测到冲突后重发的等待时间使用 BEB
- 如果失败次数超过了 15 次, 放弃重发

因此以太网的 MAC 协议提供的是无连接不可靠的服务, 因为显然没有连接, 而且可能放弃.

#problem[
  在经典以太网中, 有A, B和C共3个站点, 采用CSMA/CD 和 BEB(二进制指数回退算法). 假设所有站点都未开始发送消息. 当下面这些事件按顺序发生之后, 哪些说法是正确的? 你观察这些事件的顺序:
  + A 成功发送了一帧
  + A 和 B 都发送了帧, 出现冲突
  + A 成功地重新发送了一帧

  A. A将重新等待两个时隙\
  B. A和B处于不同的工作状态\
  C. B准备好发送下一帧, 不执行BEB\
  D. B已经等待了至少两个时隙

  #solution[
    AB冲突后, 他们按照BEB将从 ${0 ,1}$ 个时隙中随机选择进行等待, 之后 A 成功发送而 B 暂时没有发送表明 A 选择等待 0 时隙, B 选择等待 1 时隙, 故显然选择 BD.
  ]
]

#problem[
  假定1km长的CSMA/CD网络的数据率为1Gb/s. 设信号在网络上的传播速率为200000km/s. 求能够使用此协议的最短帧长.
  #solution[
    $
      2D = 2 dot 1000/(200000 dot 10^3) = 10^-5 \
      1 Gbps dot 10^-5 = 10^4 bits = 1250 Bytes
    $
  ]
]

===== 带冲突避免的 CSMA (CSMA/CA)
*有确认*机制, 是*无线*局域网中最常见的介质访问控制协议, 这是因为无线不能边发边听, 所以不能用 CSMA/CD.

=== 受控访问协议
==== 位图协议
$N$ 台机器发消息之前要先经过一个 $B$ 个比特时间的竞争期, 期间每台机器在各自的一个比特时间内发送 $1$ 举手表示自己有数据要发, 竞争期结束之后是传输期, $N$ 台机器根据比特位从低到高各自排队发送.

==== 二进制倒计数协议
上一个协议中, 如果参与的计算机太多, 竞争期就会很大, 效率不高.

每个计算机分配一个 $log_2 N$ 的编号. 竞争期内相应地也有 $log_2 N$ 个比特时间, 每个比特时间内各自发送自己的对应位, 所有计算机在同一时间内发送的位求或, 如果一台机器发现结果和自己的对应位不一样, 那就退出竞争, 一直这样决出得到发送权的机器.

有优先级, 编号越大优先级越高.

==== 令牌传递协议
令牌在环状的网络中轮流.
- 发信: 取得令牌时, 查看令牌中有无数据
  - 无数据: 把数据插入令牌, 令牌成为数据帧. 当令牌下一次到达时, 本机负责把令牌中的数据删除
  - 有数据: 等待令牌下一次到达
  然后把令牌递给下一台机器
- 收信: 取得令牌时, 查看令牌中有无数据, 数据是否发给自己, 如果是, 那么受到了数据, 然后把令牌递给下一台机器


== 以太网
从参考模型看, 这部分设计覆盖了物理层和数据链路层, 但是 IEEE 802.3 只覆盖了物理层和 MAC.

=== 分类
==== 经典以太网
使用 CSMA/CD, 曼彻斯特编码, 有以下几种传输介质
#table(
  columns: 5,
  align: center,
  [特点], [10Base-5], [10Base-2], [10Base-T], [10Base-F],
  [线缆类型], [粗缆], [细缆], [双绞线], [光纤(Fiber)],
  [最大长度], [500m], [185m], [100m], [],
  [安装难度], [不易安装], [比粗缆易安装], [], [],
  [拓扑结构], [物理总线拓扑], [], [物理星状拓扑, 逻辑总线拓扑], [],
)

线缆名字中, 10 是指速度为 10mbps, 前二者的 5 和 2 指的是传输距离, 后者的 T 指的是传输介质.

==== 交换式以太网
集线器, 中继器慢慢被交换机替代, 形成了交换式以太网.

交换机可以对所连接的任意两个接口进行无冲突的通信(通过交换机内部 $n^2$ 的阵列交换点形成虚拟电路), 端口和工作站形成无冲突域, 每个端口所在的 LAN 段形成独立冲突域, 效率高.

如果交换机端口不是全双工, 而是半双工, 那还是要用 CSMA/CD 防止冲突.

=== 帧格式
精品背书课.

==== 地址
最高字节的最低位是单播(0)/组播(1)切换位, 次位是全局(0)/本地(1)切换位.

=== L2 交换
交换机需要按照地址把数据发送到对应端口, 但是交换机是即插即用的透明设备, 需要学习才能知道什么端口是谁.

当数据来到交换机的时候, 以下情况:
+ 交换机的地址表中不存在目标地址, 或者目标地址就是广播地址, 于是广播(向除了源端口的其他端口发送), 并且把源端口和其地址记录(或更新)在路由表中
+ 交换机的地址表中存在目标地址
  + 目标地址对应的端口就是源端口, 丢弃这一帧, 并更新路由表中的源端口地址
  + 目标地址对应的端口不是源端口, 把一帧传送到目标端口, 并更新路由表中的源端口地址

表中存储的地址-端口对都是有时限的, 如果长时间没有更新就会删除.

交换方式有三种:
- 存储转发: 缓存完整帧, 然后转发. 转发前要进行CRC校验. 出错少, 但是慢
- 直通交换: 读取到帧的目标地址后, 立即在源端口和目标端口之间建立通道, 转发这一帧, 出错多, 但是快
- 无分片交换: 介于两者之间. 接收到帧的前64帧再开始转发, 因为冲突往往在刚开始传输的 64 字节内, 这样做可以过滤冲突碎片.

交换机工作在物理层和链路层, 因为他们接收转发物理信号, 而且需要根据物理地址决策.

交换机是全双工, 所以计算全双工状态的总带宽时要注意乘2.

交换机是工作在混杂模式的设备, 也即网卡会接收所有监听到的包, 无论目标是不是自己, 因为交换机要进行转发, 所以这是必须的. 而正常模式(一般情况下的模式)下, 网卡则只处理目标是自己的包.

网桥就是旧版本的交换机, 行为和交换机一样.


== VLAN
人工限制交换机的广播域(分隔广播域), 使用的标准是 IEEE 802.1Q.

== 生成树协议 STP
在交换机上运行, 通过选举根节点和到根节点的端口并屏蔽其他端口阻断物理链路中的回路, 解决广播风暴等问题. 使用的标准是 IEEE 802.1D.

== 无线技术
- ZigBee: 物联网用的多
- 蓝牙: 基本单位是微微网(Piconet)
- WiFi

只有 WiFi(IEEE 802.11) 是无线局域网协议, 其他都是个域网.

= 网络层
寻路.

提供的服务有两种.
#table(
  columns: 3,
  [服务], [数据报网络], [虚电路网络],
  [有无连接], [无], [有],
  [数据寻径], [每个分组独立寻径], [每个分组只带有连接号, 不需要自己寻径],
  [抗毁性], [故障不会瘫痪网络, 分组可以自由寻路], [连接发生故障需要重新搭建],
  [到达顺序], [乱序到达], [按序到达],
  [状态], [无状态], [有状态],
  [服务质量], [难以保证], [可以保证],
)

== IPv4 协议
注意, IPv4 并不能保证分组不丢失.

=== 分组格式
精品背书课.


=== 分片
链路层的 MTU 的限制会导致分片.

IPv4 分组中存在标记位:
- DF(Don't Fragment): 若为 0 表示可以分片, 为 1 表示不要分片
- MF(More Fragment): 若为 0 表示这是最后一个分片, 为 1 表示还有更多分片

如果分组长度 $L$ 大于转出网络 MTU $M$(对于以太网来说, MTU 是 1500 Bytes), 且分组中 DF 为0, 那么一片的载荷长度为
$
  d = floor((M - H)/8) * 8
$
这里是为了保证分片长度为8字节整数倍, 因为分片偏移的单位是8字节.

总分片数为
$
  n = ceil((L - H)/d)
$
其中 $H$ 为头部长度, 往往为 20.

#problem[
  节点 A 到 B 通过路由器 R1 和 R2 路由. 通过网络发送的 IP 数据报有 20 字节长的报头. A-R1 链路的 MTU 是1800 字节, R1-R2 链路的 MTU 是 1200 字节, R2-B 链路的 MTU 是 600 字节. 如果 A 想要发送长度为 2800 的消息, 问: B 接收的数据报的总个数是多少? (假定源数据报中的DF=0).

  #solution[
    首先计算出各个链路允许的最大有效载荷.
    $
      floor((1800-20)/8) dot 8 = 1776 Bytes \
      floor((1200-20)/8) dot 8 = 1176 Bytes \
      floor((600-20)/8) dot 8 = 576 Bytes \
    $

    于是
    $
      (2800) cases(
        1796(1776) cases(
          1196(1176) cases(
            596(576),
            596(576),
            44(24)
          ),
          620(600) cases(
            596(576),
            44(24)
          )
        ),
        1044(1024) cases(
          1044(1024) cases(
            596(576),
            468(448)
          )
        )
      )
    $
    共 7 个.
  ]
]

=== IPv4 地址
本质属性是位置相关性.


一些特殊地址
#table(
  columns: 3,
  [名称], [地址], [备注],
  [受限广播地址], [全1], [只做目的地址, 向全网主机广播, 实际上只是本地广播],
  [未指定地址], [全0], [只用作特殊情况下的源地址],
  [网络广播地址], [网络号.全1], [只做目的地址, 向对应网络],
  [网络地址], [网络号.全0], [不做源或目的地址, 代表网络本身],
  [环回地址], [127.\*], [用于本机测试, 注意 127.0.0.0 不行, 因为是网络地址],
)

私人地址空间:
- 10.\*
- 172.16.\* - 172.31.\*
- 192.168.\*

ABCD类地址: 看第一个八位组开头有几个连续1, 0个是A, 1个是B, 依此类推.

=== CIDR 无类域间路由
没有 ABCD 类地址限制, 可以按需分配网络号长度(VLSM 可变长子网掩码), 所以
- 缓解 IP 地址耗尽(通过 VLSM)
- 减小路由表规模(CIDR 路由汇聚)
- 按需分配 IP 地址
- 统一管理不同类别 IP 地址

==== 子网划分
先分配地址多的, 再分配地址少的, 分配的时候可以基本按照树状的分配方式.

需要注意, 如果子网内有 $n$ 台客户机需要上网, 则实际上至少需要 $n+3$ 个IP, 因为需要
- 子网本身的地址
- 子网广播地址
- 网关自身的地址




=== 其他IP协议或技术
==== ARP地址解析协议
主机发信需要对方的MAC, 但是有时候只知道IP不知道MAC, ARP就是用来通过IP获得MAC的协议.

===== 数据帧格式
精品背书课.

===== 基本工作原理
基本工作方式为:
+ 一方发送ARP请求, 其中目标硬件地址保留全零
+ 由于目标地址是*广播*地址, 所有主机都会接受
+ 除了目的主机, 其他主机不理睬
+ 目的主机收到后发送ARP应答, 其中所有地址都填好, 因此*不再是广播*
+ 源主机收到应答并获得地址

每个主机都会维护一个ARP表, 按如下方式更新
- 发出请求, 接到应答后按应答更新
- 收到请求的主机, 无论是不是目标, 都提取请求中的发送方地址更新

实际上记录都有生存时间, 时间太长自动删除. 如果主机启动或者重新配置网卡, 主机会广播一个免费ARP请求, 目标和发送方都是他自己, 之前存储过这台机器的接收到这个请求就会用里面的信息更新. 除此之外, 免费 ARP 请求的发送和接收方都是自己, 不期望得到任何回答, 如果得到了, 说明有地址冲突, 所以也可以用来*检测 IP 地址冲突*.

如果是对远程网络中的主机ARP, 则最开始要把路由器MAC设置为目标MAC, 路由器拿到ARP请求后再根据IP地址在网络层进一步处理, 直到路由器拿到MAC地址, 再重新封装一个ARP应答发给源主机.

==== ICMP

消息格式中包含类型, 代码, 校验和:
- 差错报告
  - 类型3
    - 主机不可达消息
    - 端口不可达消息
    - 需要分片但不允许消息
  - 类型11
    - 超时消息
    - 重组超时消息
- 查询信息类型
  - 类型8: 回声请求
  - 类型0: 回声应答

几种情况对应的差错:
- 不可达: 超时
- 拥塞: 源抑制

PMTU 利用 ICMP 发现链路上的最大 MTU.


==== NAT网络地址转换
让多个私有IP的主机通过同一个公有IP连接外部网络, 具体做法就是
- 内网分组到达NAT转换器, NAT转换器修改源IP为公有IP, 并且分配一个端口号, 对转换前后的端口号和源IP做好记录
- 转发
- 收到回信, 按照记录好的端口号, 源IP修改回信
- 转发

这个服务是完全透明的.

== IPv6 协议

=== IPv6地址
128位, 记作 $8 times 4 times 4$ 的冒分十六进制. 也有和 IPv4 一样的前缀表示法.

一些特殊地址
#table(
  columns: 3,
  [名称], [地址], [备注],
  [站点本地地址], [fec0::/48], [],
  [组播地址], [ff00::/8], [],
  [链路本地地址LLA], [fe80::/10], [],
  [全球单播地址GUA], [现在往往是2或者3开头], [],
  [子网路由器任播地址], [网络号后全0], [],
)

任播地址做目的地址时, 包会发送到最近的一个该地址的接口. 其实任何一个单播地址都能成为任播地址: 只要他被分配给多个接口, 而且这个接口明确知道自己这个地址是任播地址.

省略规则:
- 前导零必须省略, 如 $0001 -> 1$
- 最长零省略, 如果有连续多组四位十六进制全为0, 那就全都省略为一个 `::`, 最长的优先, 等长最前面的优先, 不省略一组0.


=== IPv6 过渡技术
- 双协议栈技术
  - 一般: 一个机器同时支持两种协议, 要和什么协议的机器交互就用什么协议
  - 双协议栈过渡机制: 在最后的过渡期服务少数的 IPv4 主机, 在一个纯 IPv6 网络内提供一个类似 NAT 服务的 DSTM 服务器和一个双栈的 TEP 端点, 网络内主机通过 DSTM 获取 NAT 后的 IPv4 地址, 把整个包封在 IPv6 帧里面通过 TEP 和纯 IPv4 主机交互.
- 隧道技术
  - IPv6 over IPv4: 多为协议41封装, 也即 IPv4 分组中的协议字段为41, 数据段即为纯 IPv6 分组
  - IPv4 over IPv6
- 网络地址转换-协议转换 NAT-PT: 通过一个双栈网关作为代理沟通两种纯 vX 的主机(通过做NAT和PT), 但是对于部分双栈机器可以直通.

=== 其他 IPv6 技术
==== 邻居发现(ND)
是通过 ICMPv6 实现的.

==== ICMPv6

"ICMPv6用于主要用于报告IPv6分组的传输问题".

== 路由协议
作用是自动学习网络并维护路由表, 从而达到寻路的目的.


=== 距离矢量路由协议(DV)
基本上分为三步
- 维护距离矢量
- 交换距离矢量
- 更新距离矢量

每个路由器维护一个他到其他所有节点的距离的矢量, 与邻居交换信息的时候通过自己到邻居这条路径优化自己的矢量.

RIP 协议就是一个 DV 协议的例子.

RIP 协议默认用跳数量度, 每个 RIP 路由器周期性和邻居交换, 默认30s一次, 最大量度为15跳, 再高认为不可达, 缺点有
- 收敛慢
- 不能到15跳之外
- 路径量度不合理

除此之外, 还有 IGRP, BGP 也是 DV.

=== 链路状态路由协议(LS)
基本运作:
- 发现邻居: 通过 Hello 报文
- 设置链路: 了解自己和链路的状况, 并为此链路设置量度, 代价, 开销
- 构造 LSA(链路状态公告): 一个小地图, 包括邻居信息, 到邻居的链路, 链路上的量度
- 分发 LSA: 把LSA发给其他所有路由器
- 计算: 构建以自己为根, 到其他所有路由器的最短路径, 以及最短路径生成树

==== OSPF协议
开放, 使用带宽量度, 无类, 收敛快, 无路由环, 有层次性.

运行过程
- 建立全毗邻关系: 相互交换数据, 同步数据库
- 选举 DR指定路由器 和 BDR备用路由器: 为了减少同步次数
- 发现路由: 从邻居交换的信息里面获取新的路由
- 计算最佳路由
- 维护路由: 默认30min更新一次

用到五种报文:
- Hello: 发现邻居, 建立和维护关系
- DD(Database Description): LSA摘要
- LSR(Link State Request): 要求详细的LSA
- LSU(Link State Update): 回应 LSR 或主动发送链路变化
- LSAck(Link State Acknowledgement): 确认收到

全毗邻关系的建立过程和状态迁移.

=== BGP
前面的协议都是 IGP, 也即在自治系统(AS)内部运行的路由协议. AS之间运行的是BGP, BGP 也是一种 DV.

BGP报文中包含路径属性, 包括
- 起点
- AS路径: 记录了完整路径, 可以防止环路
- 下一跳
- 多出口辨识属性
- 本地优先属性

=== IP 组播

IGMP互联网组管理协议: 在主机和组播路由器之间建立, 维护和拆除组播组成员关系.

- 源树: 组播源为根到组播组成员的树, 每个组播源都会生成一个
- 共享树: 组播源发出的分组先到达一个汇聚点, 然后再从汇聚点转发到组播组成员, 每个组播组只有一个

有一系列组播路由协议:
- 域内
  - 密集模式: 只支持源树
    - DVMRP
    - PIM-DM: 使用泛洪-剪枝的方式找到源树, 也即"推"模型
  - 稀疏模式: 同时支持共享树和源树
    - PIM-SM: 接收者需要显式加入, 也即"拉"模型
    - CBT
  - 链路模式
    - MOSPF
- 域外
  - MSDP(链接PIM-SM域)
  - MBGP(BGP多协议拓展)

组播有一系列优势, 包括
- 降低网络流量
- 降低应用服务器的负担
- 降低干线上的流量

== QoS
区分服务质量.

=== 漏桶算法
数据先传送到一个缓冲区, 从缓冲区中匀速抽取数据发送, 缓冲区满后超出的数据将会被丢弃.

不支持突发.

=== 令牌桶算法
漏桶算法的反演. 匀速向令牌桶中填充令牌, 令牌桶有一定容量, 多出的令牌将被丢弃, 数据只有从令牌桶中取得令牌才能发送.

支持一定程度的突发.

#problem[
  一个网络节点在网卡前接了一个令牌桶和漏桶, 令牌桶的容量C为10000KB, 令牌产生的速率是25MBps; 漏桶的容量是8000KB, 输出速率是125MB/s.
  + 如果网络节点产生了大量分组, 令牌桶的输出速度达到了50MB/s, 以这样的速度输出, 最多可以持续多长时间?
  + 如果网络节点某个时刻产生的分组突然增加, 产生了50MB的分组, 假如令牌桶已经在空闲时间积攒了满桶的令牌, 发送完50MB的全部分组, 需要多长时间? 不计算漏桶处理分组的时间.
  #solution[
    + 设能持续时间 $t$, 则有
      $
        25 t + 10 = 50 t => t = 0.4 "s"
      $
    + 设以 125 MBps 的速度输出了 $d$ 大小的数据, 则有
      $
        d/125 dot 25 + 10 = d => d = 12.5
      $
      持续 0.1s.

      之后又以 25MBps 的速度输出了 37.5 MB 数据, 持续
      $
        37.5/25 = 1.5 "s"
      $
      共 1.6s.
  ]
]

=== 多标签交换MPLS
面向连接, 转发的时候和标签交换(LS)类似, 只需要检查标签, 替换标签, 转发分组. 运行在 OSI 模型的 "2.5" 层.

可以用专用电路实现, 效率高.

= 传输层
实现进程到进程的通信.

有无连接, 区别在于有无虚电路.
== UDP
可以用于 RPC 等.

=== 段格式
精品背书课.

== TCP

=== 可靠数据传输机制
+ 序号机制: 每个字节都有编号, 数据段的编号是第一个字节的编号.
+ 确认机制: 确认号是期望收到的下一个数据段的序号, 也即已经成功接收的数据号的后继. TCP 使用累计确认, 如果确认了后来的数据, 表示前面的数据也已经成功接收.
+ 重传机制
  + 计时器超时: 太长时间没收到确认就重传, 超时时间设置为预估的往返时间
  + 三次重复确认: 如果中间一个丢失了, 后面的正常发送, 于是对于后面正常接收的每一个, 都会回复一个丢失包的序号的确认, 三次重复确认就会使发送方重传.

=== 滑动窗口流量控制
TCP是全双工传输, 所以两方都各自维护自己的发送窗口和接收端口.

所谓窗口也即发出去了但是对方还没回复(自己还没处理完)的包的最大长度, 双方可以用数据段里面的接收窗口值告知对方调整发送窗口.

糊涂窗口综合征: TCP流控不良, 窗口非常小, 头部显得非常大, 额外开销过高. 解决方案有
+ Nagle算法: *发送方*先收集要发送的小数据, 到达一定量或者收到对方确认之后再发送.
+ Clark算法: *接收方*收到数据段就确认, 但是直到缓冲区足够大之前一直宣布窗口为0, 也即暂停接收.

拥塞窗口: 发送方维护, 用于限制自己, 不需要通告接收方. 实际的发送窗口是接收窗口和拥塞窗口的最小值.



#problem[
  如果一个TCP数据段的接收方, 向发送方发出了一个确认消息, 其中的ACK确认号和窗口尺寸两个字段的值分别是: ACK=12000, WIN=8000. 下列哪一项不是发送方的可以传输的有效的数据段?
  + 发送方可以传输 2000 字节数据段, SEQ = 18100
  + 发送方可以传输 1500 字节数据段, SEQ = 18100
  + 发送方可以传输 1000 字节数据段, SEQ = 18000
  + 发送方可以传输 2000 字节数据段, SEQ = 17000
  #solution[
    接收方确认到 11999, 期望 12000 的时候还有 8000 的窗口, 所以说新发给他的数据不能超过 8000, 也即末尾序号不能超过 $12000 + 8000 - 1 = 19999$, 显然第一个选项超过了.
  ]
]


=== 连接的建立
也即所谓三次握手:
+ 客户端向服务端, SYN设置为1, seq值设置为随机值 $x$, 数据段无数据, 但是占一字节
+ 服务端向客户端, SYN和ACK设置为1, seq为随机值 $y$, ack为 $x + 1$, 数据段无数据, 但是占一字节
+ 客户端向服务端, ACK设置为1, seq 为 $x+1$, ack为 $y + 1$, 这次可以包含数据, 也可以不包含, 也即数据长度为0

=== 连接的释放
分为
- 对称释放: 两方独立完成连接释放并收到对方确认
- 非对称释放: 只要一方完成连接释放的,请求并收到确认即可

==== 非对称释放
断开一方直接发送 DR 并关闭连接.

==== 对称释放
所谓四次挥手.

+ 客户端向服务端, FIN设置为1, seq 为 $x$(并非随机, 而是真实值), 数据占用1字节
+ 服务端向客户端, ACK为1, seq 为 $y$, ack为 $x+1$, 此时客户端向服务端的连接已经关闭.
+ 服务端向客户端, FIN为1, ACK为1, seq为 $z$(不一定是 $y+1$, 可能在单向连接关闭之后又发了一些), ack为 $x+1$, 数据占用1字节
+ 客户端向服务端, ACK为1, seq为 $x+1$, ack为 $z+1$, 然后等待两倍的最长段寿命(MSL, 一般为2min)后服务端向客户端的连接正式关闭



=== 计时器
TCP的状态需要多种计时器维护, 包括

==== 重传计时器
太长时间没收到确认就重传, 超时时间设置为预估的往返时间(RTT).

RTT的估计使用指数加权移动平均, 也即逐渐修正
$
  "SRTT" <- (1-alpha) "SRTT" + alpha R
$
其中 $alpha$ 是平滑因子, 越大则更新越平滑, 一般取 $alpha = 1 / 8$.

也有其他的估计方法.

==== 持续计时器
接收方有时候会把窗口设置为0主动停止接收信息, 直到他再次把窗口设置为其他值, 但是有时候还原窗口的消息丢失了, 这就会造成暂停状态无法解除.

所以我们设置了持续计时器, 如果*发送方*收到的消息中rwnd设置为0, 则开启计时器, 超时时则主动发送一个探测数据段(只有1字节新数据)触发对方重发一个确认数据段(which 重新设置了rwnd), 并且同时再启动一个新的持续计时器.

虽然探测数据段中有 1 字节新数据, 但是我们必须考虑接收方不会接收它(毕竟窗口officially还是0), 所以我们后续的数据段的seq忽略这1字节.

==== 保活计时器
防止长期空连接.

每收到一次客户端数据段就重置计时器, 超时的时候*服务端*就主动发送一个探测数据段, 连续10个探测数据段都没收到回应则认为客户端失联, 主动关闭连接.

==== 时间等待计时器
主要用于连接释放阶段, 也即前面提到的等待两倍的最长段寿命(MSL, 一般为2min)后服务端向客户端的连接正式关闭.

=== 拥塞避免
- 慢启动阶段: 有一个初始拥塞窗口大小, 比如 1 倍MSS(最大段数据), 每次发完收到对方确认后, 就把拥塞窗口加倍
- 拥塞避免阶段: 慢启动达到阈值(窗口达到阈值或者出现拥塞(超时))后, 进入线性增加阶段, 每次增加1MSS
- 网络拥塞时间发生阶段: 发生拥塞, 把阈值设置为当前拥塞窗口的一半, 然后拥塞窗口设置为1, 然后重新进入慢启动阶段
- 快速重传和恢复阶段: 如果只有个别数据丢失(比如三次重复确认), 就立即重传, 把阈值设置为窗口的一半, 窗口设置为新的阈值, 然后进入拥塞避免阶段

#let struc-table(width: auto, height: 2em, info: none, body) = {
  theme-frame(theme => {
    stack(dir: ttb, box(height: 1.5em, info), ..body
      .split(none)
      .map(x => stack(dir: ltr, ..x.map(x => {
        let (len, body) = x
        box(width: len * width, height: height, stroke: 1pt + theme.main-color, align(center + horizon, body))
      }))))
  })
}

== QUIC
新型协议, 基于 UDP.

优势包括:
- 基于 UDP, 延迟低
- 传输性能高
- 安全, 默认 TLS 1.3
- 解决 TCP 队头堵塞问题
- 提供可插拔的拥塞控制机制
- 可以连接迁移

= 应用层
== 域名系统
arpa 不是常见的顶级域名(TLD).

== 典型应用
=== 远程登录
- telnet: 简单的远程终端协议, 最大问题是不安全
- SSH: 安全

=== 电子邮件
包括用户代理(UA), 邮件传输代理(MTA), 和邮件发送协议.

发送用 SMTP, 接收用 POP3.

== 万维网
URL 是统一资源定位符, 给各种资源一种唯一的, 抽象的识别方法.

万维网的基本组成元素是 Web 服务器, Web 浏览器, HTML.

在客户/服务器模型中, 客户和服务器程序相互独立.

= 其它
== 各协议 PDU 及相关数值
- 物理层: 比特流
- 链路层: 帧
  #struc-table(width: 1.8em, info: [每行 22 字节], (
    (8, [前导码8B]),
    (6, [目的地址6B]),
    (6, [源地址6B]),
    (2, [长度2B]),
    none,
    (22, [数据+填充 46-1500B]),
    none,
    (4, [校验和4B]),
  ))
  这是 IEEE 802.3 格式的帧, 现在通行的 DIX 在前导码上有略微不同, 且长度字段为类型.
- 网络层: 分组
  - IPv4
    #struc-table(width: 1.2em, info: [每行 32 位], (
      (4, [版本 4b]),
      (4, [头部长 4b]),
      (8, [服务类型 8b]),
      (16, [总长度 16b]),
      none,
      (16, [标识(分组序号) 16b]),
      (1, []),
      (1, [DF]),
      (1, [MF]),
      (13, [片偏移 13b]),
      none,
      (8, [TTL 8b]),
      (8, [协议 8b]),
      (16, [头部校验和 16b]),
      none,
      (32, [源IP 32b]),
      none,
      (32, [目的IP 32b]),
      none,
      (32, [选项...]),
      none,
      (32, [载荷 32b]),
    ))
    - 头部长度: 单位为4字节
    - 总长度: 单位为字节
    - 片偏移: 单位为8字节
  - IPv6
    #struc-table(width: 1.2em, info: [每行 32 位], (
      (4, [版本]),
      (8, [流量类型]),
      (20, [流标签]),
      none,
      (16, [载荷长度]),
      (8, [下一个头]),
      (8, [跳数限制]),
      none,
      (32, [源 IP 地址]),
      none,
      (32, [源 IP 地址]),
      none,
      (32, [源 IP 地址]),
      none,
      (32, [源 IP 地址]),
      none,
      (32, [目的 IP 地址]),
      none,
      (32, [目的 IP 地址]),
      none,
      (32, [目的 IP 地址]),
      none,
      (32, [目的 IP 地址]),
      none,
      (32, [0-6个扩展头]),
      none,
      (32, [载荷]),
    ))
    - 下一个头代替了协议
    - 扩展头有
      - 逐跳选项
      - 路由头RH
      - 分片头FH
      - 认证拓展头AH
      - 封装安全载荷拓展头ESP
      - 目的选项拓展头
- 传输层
  - TCP: 段
    #struc-table(width: 3em, info: [每行 8 字节], (
      (2, [源端口号]),
      (2, [目的端口号]),
      (2, [总长度]),
      (2, [校验和]),
    ))
  - UDP: 数据报
    #struc-table(width: 9em, height: 2.5em, info: [每行 4 字节], (
      (2, [源端口号]),
      (2, [目的端口号]),
      none,
      (4, [序号seq]),
      none,
      (4, [确认号ack]),
      none,
      (1 / 2, [头部长度]),
      (6 / 8, [保留]),
      ..(
        "URG",
        "ACK",
        "PSH",
        "RST",
        "SYN",
        "FIN",
      ).map(x => (
        1 / 8,
        stack(dir: ttb, ..x.clusters().map(box.with(height: 0.8em))),
      )),
      (2, [接收窗口]),
      none,
      (2, [校验和]),
      (2, [紧急指针]),
      none,
      (4, [选项 $n times 4 Bytes$]),
      none,
      (4, [数据]),
    ))

相关数值
- 头部开销
  - IP: 20 Bytes
  - TCP: 20 Bytes
- MTU(包含头部)
  - 以太网(不含前导码): 64 Bytes (出于 CSMA/CD 要求)
  - IP: 576 Bytes
- 最大帧长
  - 以太网(不含前导码): 1518 Bytes
- 最大头部长度
  - IPv4: 64 Bytes, 因为头部长度字段单位为 4 Bytes, 本身站 4 bits
- 最大有效载荷
  - IP: 65515 Bytes
  - TCP: 65495 Bytes

== 广播域和冲突域
路由器的一个端口就是一个广播域和一个冲突域.

交换机能分割冲突域, 集线器不能.
